#+TITLE: Knuth-Bendix Completion in miniKanren
#+AUTHOR: Brandon T. Willard
#+DATE: 2019-03-28
#+EMAIL: brandonwillard@gmail.com

#+STARTUP: hideblocks indent hidestars
#+OPTIONS: author:t date:t ^:nil toc:nil title:t tex:t d:(not "logbook" "todo" "notes")
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport

#+PROPERTY: header-args :eval never :exports both :results output drawer replace :noweb yes
#+PROPERTY: header-args+ :session mk-rewrites

#+SETUPFILE: latex-setup.org
# #+INCLUDE: org-setup.el

#+BEGIN_abstract
An investigation into the use of the Knuth-Bendix completion algorithm in
miniKanren.
#+END_abstract

* Introduction

Consider the following subset of group axiom identities--specifically, inverse elements,
identity elements, and associativity:
\begin{equation}
  \begin{aligned}
    e \cdot x &= x
    \\
    x^{-1} \cdot x &= e
    \\
    (x \cdot y) \cdot z &= x \cdot (y \cdot z)
  \;.
  \end{aligned}
  \label{eq:group-axioms}
\end{equation}

In miniKanren [[citep:ByrdRelationalProgrammingminiKanren2009]], we can produce
a uni-directional rewrite relation based on [[Cref:eq:group-axioms]] as
follows:
#+NAME: mk-algebra-rewrite-example-defs
#+BEGIN_SRC scheme :eval yes :exports code :results silent :noweb strip-export
<<scheme-setup>>
<<rewrite-functions>>
<<graph-relations>>

(define reduces
  (lambda (a b)
    (conde
     ((fresh (x)
        (== a `(* e ,x))
        (== b x)))
     ((fresh (x)
        (== a `(* (i ,x) ,x))
        (== b 'e)))
     ((fresh (x y z)
        (== a `(* (* ,x ,y) ,z))
        (== b `(* ,x (* ,y ,z))))))))
#+END_SRC

When accompanied by a relation, src_scheme{graph-applyo}, that traverses forms,
reduction relations will produce every applicable reduction--as shown in Listing
[[mk-algebra-rewrite-example-1]].
If the rewrite rules adhere to a reduction order, then we should eventually see
some normal (i.e. irreducible) forms among the output of successful goals.  At
those points, the src_scheme{conde} branches in the
underlying src_scheme{graph-applyo} recursions should be exhausted and the goal
streams end.  The remaining successful goals produce non-normal (i.e. further
reducible) forms.  We can see all of these cases in the output of Listing
[[mk-algebra-rewrite-example-1]].
#+NAME: mk-algebra-rewrite-example-1
#+BEGIN_SRC scheme :eval yes :exports both :results output code :noweb strip-export
(display (pretty-format
          (run* (q) (graph-applyo reduces '(* (* (i x) x) y) q))
          25
          #:mode 'display))
#+END_SRC

#+RESULTS: mk-algebra-rewrite-example-1
#+begin_src scheme
((* (i x) (* x y))
 (* e y)
 y)
#+end_src

:REMARK:
Outside of the miniKanren context and under the same rewrite rules, in Listing
[[group-normalize-order-1-example]] we obtain the same results as Listing
[[mk-algebra-rewrite-example-1]], except that the intermediate reductions are not
shown and only the normal form is returned.
#+NAME: group-normalize-order-1-example
#+BEGIN_SRC scheme :eval yes :exports both :results value code :noweb strip-export
<<scheme-setup>>
<<rewrite-functions>>

(let ([rules (rewrite-rules (x y z)
               ((* (* x y) z) -> (* x (* y z)))
               ((* e x) -> x)
               ((* (i x) x) -> e))])
  (normalize rules '(* (* (i x) x) y)))
#+END_SRC

#+RESULTS: group-normalize-order-1-example
#+begin_src scheme
y
#+end_src
:END:

In Listing [[mk-algebra-rewrite-example-defs]] we only considered the rewrite rules for
left-to-right substitutions implied by the equations of [[Cref:eq:group-axioms]].
It just so happens that this set of rewrite rules actually does reduce terms,
and--as a result--can produce normal forms.

Now, consider the normal form for \((x \cdot x^{-1}) \cdot y\); as with our
example above, it should be \(y\).  Our naively derived rewrite
rules will not produce the expected normal form, because the identity \(x \cdot
x^{-1}\) is not present--although it is implied by [[Cref:eq:group-axioms]].

Unfortunately, the addition of new rewrite rules to compensate for this
deficiency can easily remove any reducibility guarantees afforded by our original set
of rules.  For instance, if we add commutativity \(x \cdot y \to y \cdot x\), even
in more restricted forms, we will produce a non-terminating rewrite system.

In a more general context, we need a means of automatically deriving rewrite
rules with normalization and confluence guarantees.  These properties are also required
for type checking relations and other rewrite-driven operations that,
say, determine the validity of statements like "Is \(x \cdot x^{-1} = e\) also
true/valid under [[Cref:eq:group-axioms]]?".  Knuth-Bendix completion is one such
approach, and it works by producing a set of "complete" rewrite rules for a
given set of equations.

For example, a complete set of rewrite rules for [[Cref:eq:group-axioms]] is given
by the following:
\begin{equation}
  \begin{aligned}
    e \cdot x &\to x
    \\
    x^{-1} \cdot x &\to e
    \\
    (x \cdot y) \cdot z &\to x \cdot (y \cdot z)
    \\
    x^{-1} \cdot (x \cdot y) &\to y
    \\
    e^{-1} &\to e
    \\
    x \cdot e &\to x
    \\
    (x^{-1})^{-1} &\to x
    \\
    x \cdot x^{-1} &\to e
    \\
    x \cdot (x^{-1} \cdot y) &\to y
    \\
    (x \cdot y)^{-1} &\to y^{-1} x^{-1}
  \;.
  \end{aligned}
\label{eq:group-completion}
\end{equation}

The rewrite rules in [[Cref:eq:group-completion]] can be produced mechanically from
[[Cref:eq:group-axioms]]--and a generic reduction order--using Knuth-Bendix
completion (e.g. Huet's procedure).  As we can see, the commutative inverse
identity (i.e. \(x^{-1} \cdot x = x \cdot x^{-1}\)) is present in a form that
preserves termination, along with other important rewrites that we might have
easily missed when attempting to manually produce a complete set of rules.

miniKanren implements a complete search [[citep:HemannSimpleCompleteSearch2018,
Hemannsmallembeddinglogic2016]], which alongside lazily evaluated results, can
be used to obtain all possible reductions under the fully enumerated set of
possible replacement rules implied by a set of equations.  However, this
approach produces infinite goal streams and only moves the standard
term-rewriting normal-form and termination concerns to the callers of said
relations.

Additionally, there are performance issues that result from the inherently large
search spaces induced by such relations.  Every matching src_scheme{conde}
clause that does not produce a normal form is essentially a wasted step.  The completions
produced by Knuth-Bendix procedures can guarantee--via (local) coherence--that
every successful unification ultimately leads to a normal form.
Likewise, some refinements [[citep:Metivierrewritingsystemsproduced1983]] of
these completion procedures are able to reduce the number of reduction rules and
quite possibly the number of redundant src_scheme{conde} clauses/unifications.


Toward the same ends, some of these issues can be mitigated through alterations
to the search process [[citep:SwordsGuidedSearchminiKanren, ZhangNeuralGuidedConstraint2018, BoskinSurprisinglyCompetitiveConditional2018]].
These approaches tend to introduce more opportunities to unknowingly violate the
relational paradigm upon which miniKanren capitalizes, but--more
importantly--they can require a distinct effort from the developer to provide
context-dependent logic that actually *does* improve the search.
In some circumstances, that logic will necessarily overlap with the aims of
term-rewriting completion described here.

For an important set of situations, we can use standard term rewriting
automations that do not involving alterations to the underlying mechanics of
miniKanren's search--or its fundamental relations/goals--and are able to provide
improvements to the specification and application of relational identities that
produce term rewriting systems.

** Notation and Implementations

In what follows, we will use \(\mathcal{R}\) to represent a set of rewrite rules
and \(\mathcal{T}\left(\mathcal{F}, \mathcal{V}\right)\) as a set of terms
derived from a set of function symbols \(\mathcal{F}\) and variables
\(\mathcal{V}\).  These are combined to form a term rewriting system
\(\left(\mathcal{R}, \mathcal{R}\right)\).

Throughout, we will use Racket to implement the term rewriting mechanics and
miniKanren implementations.

#+NAME: kanren-requires
#+BEGIN_SRC scheme :eval yes :exports code :results silent :noweb-ref scheme-setup
(require rackunit)
(require racket/pretty)
(require minikanren)

;; Include un-`provided` core functions.
(require/expose minikanren/minikanren (unify var var? reify walk*))
#+END_SRC

#+NAME: kanren-requires-debug
#+BEGIN_SRC scheme :eval yes :exports none :results silent :noweb-ref scheme-setup
;; For interactive debugging, try `raco pkg install debug` and the following:
;; (require debug/repl)
;; Then use `(debug-repl)` and `(resume)'.

;; Similarly...
(require errortrace)
#+END_SRC

:TODO:
We could/should have structs for terms, rewrite rules, etc.
This approach uses [[https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._make-reader-graph%29%29][reader graphs]], which allow us to make src_scheme{equals?}
ignore src_scheme{var} and swap out/ground variables effortlessly.

#+RESULTS: term-structs
#+BEGIN_SRC scheme :eval never :exports none :results none
;; (require racket/base)
;; (require (except-in racket cons list)
;;          (rename-in racket [cons base-cons] [list base-list]))
(require racket/generic)
(require data/order)

(define-generics term
  (ground? term)
  ;; TODO: overloading `cons' would allow us to assemble `term' objects
  ;; incrementally (e.g. union their sets of placeholders in `term-vars').
  ;; Seems like there's something I'm not understanding about this generics
  ;; interface/macro, though...
  #:defaults  ([list?
                (define (ground? term)
                  (set-empty? (vars term)))]))

(check-false (ground? `(i ,(var 0))))
(check-true (ground? `(i e)))

(struct term-graph (graph vars)
        #:transparent
        #:constructor-name make-term-graph
        #:omit-define-syntaxes
        #:guard
        (lambda (graph vars type-name)
          (cond
           [(term-graph? graph)
            (values (term-graph-graph graph) (term-graph-vars graph))]
           [else (values graph vars)]))
        #:methods gen:term
        [(define (ground? self)
           (set-empty? (term-graph-vars self)))]
        #:methods gen:equal+hash
        [(define (equal-proc a b equal?-recur)
           ;; We don't want vars to throw off the comparison, so we use the
           ;; reader graphs and their placeholders.
           (equal?-recur (term-graph-graph a) (term-graph-graph b)))
         (define (hash-proc a hash-recur)
           (hash-recur (term-graph-graph a)))
         (define (hash2-proc a hash2-recur)
           (hash2-recur (term-graph-graph a)))])

(define (term-graph form)
  (cond
   [(term-graph? form)
    (make-term-graph (term-graph-graph form) (term-graph-vars form))]
   [else
    (let* ([form-vars (vars form)]
           [ph-alist (for/list ([v form-vars]
                                [i (range (set-count form-vars))])
                       (cons v (make-placeholder
                                (string->symbol (format "*x~a*" i)))))]
           [graph (replace-in-graph ph-alist form)])
      (make-term-graph (make-reader-graph graph)
                       (for/set ([v ph-alist]) (cdr v))))]))

(let ([t1 (term-graph `(i ,(var 0)))]
      [t1-2 (term-graph `(i ,(var 1)))]
      [t2 (term-graph `(i e))])
  (printf "~a" t1)
  (check-true (equal? t1 t1-2))
  (check-false (equal? t1 t2))
  (check-false (ground? t1))
  (check-true (ground? t2)))

(struct rewrite-rule (lhs rhs)
        #:transparent
        #:guard
        (lambda (lhs rhs type-name)
          (cond
           [(not (and (term-graph? lhs) (term-graph? rhs)))
            (error type-name "Both arguments must be term graphs.")]
           [else (values lhs rhs)]))
        #:methods gen:custom-write
        [(define (write-proc rule port mode)
           (fprintf port "~a -> ~a"
                    (rewrite-rule-lhs rule)
                    (rewrite-rule-rhs rule)))])

(struct equation (lhs rhs)
        #:transparent
        #:guard
        (lambda (lhs rhs type-name)
          (cond
           [(not (and (term-graph? lhs) (term-graph? rhs)))
            (error type-name "Both arguments must be term graphs.")]
           [else (values lhs rhs)]))
        #:methods gen:equal+hash
        [(define (equal-proc a b equal?-recur)
           ;; TODO: Equality of equations should not be affected by lhs, rhs order.
           (or (equal?-recur
                (term-graph-graph (equation-lhs a))
                (term-graph-graph (equation-lhs b)))
               (equal?-recur
                (term-graph-graph a)
                (term-graph-graph b))))
         (define (hash-proc a hash-recur)
           ;; TODO: Seems like we would need an ordering for this, no?
           (hash-recur (term-graph-graph a)))
         (define (hash2-proc a hash2-recur)
           (hash2-recur (term-graph-graph a)))]
        #:methods gen:custom-write
        [(define (write-proc eqn port mode)
           (fprintf port "~a = ~a"
                    (equation-lhs eqn)
                    (equation-rhs eqn)))])

(let ([t (term-graph `(1 ,(var 0)))])
  t)

(let ([rule (rewrite-rule (term-graph `(1 ,(var 0))) (term-graph 1))])
  rule)
#+END_SRC
:END:

The macros in [[rewrite-macros]] make it easier to specify a set of rewrite rules
through the following syntax:
#+NAME: rewrite-macro-usage
#+BEGIN_SRC scheme :eval never :exports code :results none
(rewrite-rules (x y)
  ((f (g x x) y) -> (g x y))
  ((g x y) -> x))
#+END_SRC

Listing [[rewrite-macro-usage]] expands into something like the following:
#+NAME: rewrite-macro-expanded
#+BEGIN_SRC scheme :eval never :exports code :results none
'(list
  (let ((xv `((x unquote (var (gensym)))
              (y unquote (var (gensym))))))
    (replace-in-graph xv '((f (g x x) y) g x y)))
  (let ((xv `((x unquote (var (gensym)))
              (y unquote (var (gensym))))))
    (replace-in-graph xv '((g x y) . x))))
#+END_SRC

#+ATTR_LATEX: :float t :placement h!
#+CAPTION:
#+NAME: rewrite-macros
#+BEGIN_SRC scheme :eval yes :exports code :results none :noweb-ref rewrite-functions
;; Returns all the variables in a term graph.
(define (vars x [res (set)])
  (match x
   [(cons a b)
    (let* ([res (vars a res)])
      (vars b res))]
   [(? var? x)
    (if (set? res)
        (set-add res x)
        (if (member x res)
            res
            (append res (list x))))]
   [_ res]))

;; Replace elements in a term graph according to an alist.
(define (replace-in-graph xv graph)
  (match graph
    [(cons h t)
     (cons (replace-in-graph xv h) (replace-in-graph xv t))]
    [_
     (let* ([r-pair (assoc graph xv)])
       (if r-pair
           (cdr r-pair)
           graph))]))

;; Produce quoted forms each with a set of specified fresh logic variables.
(define-syntax (fresh-forms stx)
  (syntax-case stx ()
    [(_ (x ...) t)
     #`(replace-in-graph `((x . ,(var (gensym))) ...) (quote t))]
    [(_ (x ...) t ...)
     #`(list (fresh-forms (x ...) t) ...)]))

(define-syntax (rewrite-rules stx)
  (syntax-case stx (->)
    [(_ (x ...) (l -> r) ...)
     #`(fresh-forms (x ...) (l . r) ...)]))

;; Convert vars in a graph according to a function taking a number assigned to
;; each var observed (in order).
(define (transform-vars x [fn (lambda (i) (string->symbol (format "x~a" i)))])
  (let* ([x-vars (vars x '())]
         [new-vars (for/list ([v x-vars]
                              [i (range (set-count x-vars))])
                     (cons v (fn i)))]
         [x-new (replace-in-graph new-vars x)])
    x-new))

(define (print-pair delim rules)
  (cond
   [(list? rules)
    (for ([rule rules])
      (match rule
        [(cons r l)
         (printf "\t~a ~a ~a\n" r delim l)]))]
   [else
    (match rules
      [(cons r l)
       (printf "\t~a ~a ~a\n" r delim l)])]))

(define print-rule (curry print-pair "->"))
(define print-eqn (curry print-pair "="))

;; Apply a function on a grounded version of a term graph; afterward,
;; any resulting grounded terms are replaced with their original variables.
(define (apply-on-grounded fn t [lst '()])
  (let* ([t-vars (vars t)]
         [var-alist (for/list ([v t-vars])
                      (cons v (gensym)))]
         ;; Ground the vars in term `t'.
         [t-gnd (replace-in-graph var-alist t)]
         [t-new (apply fn t-gnd lst)]
         [rev-alist (for/list ([v var-alist])
                      (cons (cdr v) (car v)))])
    ;; Un-ground the grounded vars.
    (replace-in-graph rev-alist t-new)))
#+END_SRC

#+NAME: rewrite-macros-tests
#+BEGIN_SRC scheme :eval yes :exports none :results silent
(match-let ([(list v0 v1 v2 v3 v4)
             (for/list ([v (range 5)]) (var v))])
  (check-equal?
   (vars `(f (g ,v0 x (,v0 ,v2 ,v3)) ,v1 (h (j (k ,v4) ,v3))))
   (set v1 v3 v0 v4 v2)))

(match-let* ([(list (cons x_11 x_12) (cons x_21 x_22))
              (fresh-forms (x) (x . x) (x . x))])
  ;; Logic variables for equal symbols within a form should be equivalent
  (check-eq? x_11 x_12)
  (check-eq? x_21 x_22)
  ;; Across forms they shouldn't be
  (check-not-eq? x_11 x_21))

#+END_SRC

* Term Rewriting

The functions in Listing [[rewrite-helper-functions]] apply rewrite rules to a term graph.
Specifically, the function src_scheme{normalize} attempts to produce a
fixed-point/normalized result through repeated application of the rewrite rules.

#+ATTR_LATEX: :float t :placement h!
#+CAPTION:
#+NAME: rewrite-helper-functions
#+BEGIN_SRC scheme :eval yes :exports code :results none :noweb-ref rewrite-functions
;; Apply a single rewrite rule or `#f`.
(define (rewrite-1 t lr)
  (if (var? t)
      t
      (match lr
        [(cons l r)
         (let* ([θ (unify l t '())]
                [t-new (if (eq? θ #f)
                           #f
                           (begin
                             ;; (printf "------\nθ = ~a\n" θ)
                             ;; (printf "rewrite-1: [~a -> ~a]  ~a -> ~a\n" l r t (walk* r θ))
                             (walk* r θ)))])
           t-new)])))

;; Apply the first rewrite rule that unifies; return `#f` otherwise.
(define (-rewrite rules t)
  (ormap (curry rewrite-1 t) rules))

;; Apply rewrite rules until a fixed-point is reached.
(define (-normalize rules t)
  (match t
    [(cons t-car t-cdr)
     (let ([t-cdr-new (for/list ([a (if (list? t-cdr)
                                        t-cdr
                                        (list t-cdr))])
                        (-normalize rules a))])
       (if (eq? t-cdr-new #f)
           t
           (begin
             ;; (printf "normalize: ~a -> ~a\n" t-cdr t-cdr-new)
             (let* ([t-new (cons t-car t-cdr-new)]
                    [t-new-new (-rewrite rules t-new)])
               (if (or (eq? t-new-new #f) (equal? t-new-new t-new))
                   t-new
                   (begin
                     ;; (printf "normalize: ~a -> ~a\n" t-new t-new-new)
                     (-normalize rules t-new-new)))))))]
    [_ t]))

(define (rewrite rules t)
  (let ([res (apply-on-grounded (curry -rewrite rules) t)])
    (if (eq? res #f)
        t
        res)))

(define (normalize rules t)
  (apply-on-grounded (curry -normalize rules) t))

#+END_SRC

#+NAME: rewrite-helper-functions-tests
#+BEGIN_SRC scheme :eval yes :exports none :results silent
(check-equal? (rewrite (let ([q (var 0)]
                             [w (var 1)])
                         `(((g ,q ,w) . ,w)
                           ((i) . 1)))
                       '(f x y))
              '(f x y))
(check-equal? (rewrite (let ([q (var 0)]
                             [w (var 1)])
                         `(((g ,q ,w) . ,w)
                           ((i) . 1)))
                       '(g x (i)))
              '(i))

(check-equal? (normalize (let ([q (var 0)]
                               [w (var 1)]
                               [z (var 2)])
                           `(((g ,q ,w) . ,w)
                             ((f ,z) . ,z)
                             ((i) . 1)))
                         '(g (f i) (i)))
              1)
(check-equal? (normalize (let ([q (var 0)]
                               [w (var 1)]
                               [z (var 2)])
                           `(((g ,q ,w) . (+ ,q ,w))
                             ((f ,z) . ,z)
                             ((i) . 1)))
                         '(g (f (i)) (i)))
              '(+ 1 1))
(check-equal? (normalize (rewrite-rules (q w z)
                           ((+ 1 1) -> (+ 1 1))
                           ((g q w) -> (+ q w))
                           ((f z) -> z)
                           ((i) -> 1))
                         '(g (f (i)) (i)))
              '(+ 1 1))
#+END_SRC

** Critical Pairs
Following [[citet:BaaderTermrewritingall1999]] Definition 6.2.1,
#+ATTR_LATEX: :options [Critical Pairs]
#+BEGIN_definition
For \(l_i \to r_i\), \(i \in \left\{1, 2\right\}\) with
\(\bigcap_{i \in \left\{1, 2\right\}} \operatorname{Vars}\left(l_i, r_i\right) = \emptyset\),
let \(p \in \operatorname{Pos}\left(l_1\right)\) and \(\theta\) a most general
unifier of \(l_1 \mid_{p} =^{?} l_2\) s.t. \(l_1 \mid_{p}\) is not a variable, then
\(l_i \to r_i\) determine a *critical pair*
\({\langle \theta r_1, \left(\theta l_1\right)\left[\theta r_2\right]_p \rangle}\).
#+END_definition

Non-trivial critical pairs reflect a type of "critical overlap" between rewrite rules
that may lead to non-confluence.  For this reason, if we want to prove
confluence--or derive a set of confluent rewrite rules--we can focus exclusively
on the finitely many critical pairs generated by a set of rewrite rules.
We're given these properties of critical pairs through the Critical Pair lemma and theorem
[[citet:BaaderTermrewritingall1999][6.2.3 and 6.2.4, respectively]].

The functions in Listing [[critical-pairs-functions]] compute the critical pairs between
two rewrite rules.
#+NAME: critical-pairs-functions
#+BEGIN_SRC scheme :eval yes :exports code :results none :noweb-ref cp-functions :noweb strip-export
<<scheme-setup>>
<<rewrite-functions>>

(define (match-and-replace term rules matches)
  (cond
   [(not (var? term))
    (append
     matches
     (append-map
      (lambda (rule)
        (match-let* ([(cons l2 r2) rule])
          (let* ([θ (unify term l2 '())])
            (if (eq? θ #f)
                matches
                (list (cons θ r2))))))
      rules))]
   [else
    matches]))

(define (walk-matches graph rules matches [match-graph #t])
  (let* ([new-matches
          ;; Check the whole term/graph.
          (if match-graph
              (match-and-replace graph rules '())
              '())])
    ;; Descend into the term/graph.
    (match graph
      [(cons rator rands)
       (let* ([rator-matches (walk-matches rator rules '())]
              [rands-matches (walk-matches rands rules '() #f)])
         (append
          matches
          new-matches
          (for/list ([m rator-matches])
            (match-let* ([(cons θ new-rator) m]
                         [new-graph (cons new-rator rands)])
              (when (and (cons? new-graph) (not (list? new-graph)))
                  (error "rator bad cons:" rator new-rator rules))
              (cons θ new-graph)))
          (for/list ([m rands-matches])
            (match-let* ([(cons θ new-rands) m]
                         [new-graph (cons rator new-rands)])
              (when (and (cons? new-graph) (not (list? new-graph)))
                  (error "rands bad cons:" rands new-rands rules))
              (cons θ new-graph)))))]
      [else (append matches new-matches)])))

(define (critical-pairs rule1 rule2)
  (match-let* (;; Make sure that variables in rules don't overlap.
               [rule-new (transform-vars rule1 (lambda (i) (var (gensym))))]
               [(cons l1 r1) rule-new]
               [match-res (walk-matches l1 rule2 '())])
    (for/list ([m match-res])
      (match-let* ([(cons θ lrp) m]
                   [cp-car (walk* r1 θ)]
                   [cp-cdr (walk* lrp θ)])
        (cons cp-car cp-cdr)))))
#+END_SRC

The function in Listing [[all-critical-pairs]] computes all critical pairs between a
set of rewrite rules.
#+NAME: all-critical-pairs
#+BEGIN_SRC scheme :eval yes :exports code :results none :noweb-ref cp-functions
(define (all-critical-pairs rules)
  (append-map
   (lambda (rule)
     (critical-pairs rule rules))
   rules))
#+END_SRC

#+RESULTS: critical-pairs-tests
#+BEGIN_SRC scheme :eval yes :exports none :results silent :noweb yes
(let* ([expected
        '(((+ x0 x1) . (+ x0 x1))
          ((+ (s x0) x1) . (s (+ x1 x0)))
          ((+ x0 (s x1)) . (s (+ x1 x0)))
          ((s (+ x0 x1)) . (+ (s x1) x0))
          ((s (+ x0 x1)) . (s (+ x0 x1)))
          ((s (+ (s x0) x1)) . (s (+ x0 (s x1))))
          ((s (+ x0 x1)) . (+ x1 (s x0)))
          ((s (+ x0 (s x1))) . (s (+ (s x0) x1))))]
       [rules (rewrite-rules (x0 x1)
                ((+ (s x0) x1) -> (s (+ x0 x1)))
                ((+ x0 (s x1)) -> (s (+ x0 x1)))
                ((+ x0 x1) -> (+ x1 x0)))]
       [c-pairs (all-critical-pairs rules)]
       [c-pairs (remove-duplicates
                 (for/list ([cp c-pairs])
                   (transform-vars cp (lambda (i) (var i)))))])
  (check-equal? (list->set (transform-vars c-pairs))
                (list->set expected)))

(let* ([eqns (rewrite-rules (x y z)
               ((* e x) -> x)
               ((* (* x y) z) -> (* x (* y z)))
               ((* (i x) x) -> e))]
       [expected
        '((x0 . x0)
          ;; TODO: Why does the OCaml code swap these orders?
          ;; ((* x0 x1) . (* e (* x0 x1)))
          ((* e (* x0 x1)) . (* x0 x1))
          ;; ((* e x0) . (* (i x1) (* x1 x0)))
          ((* (i x0) (* x0 x1)) . (* e x1))
          ((* x0 (* x1 x2)) . (* x0 (* x1 x2)))
          ;; ((* (* x0 (* x1 x2)) x3) . (* (* x0 x1) (* x2 x3)))
          ((* (* x0 x1) (* x2 x3)) . (* (* x0 (* x1 x2)) x3))
          (e . e))]
       [c-pairs (all-critical-pairs eqns)]
       [c-pairs (remove-duplicates
                 (for/list ([cp c-pairs])
                   (transform-vars cp (lambda (i) (var i)))))])
  (check-equal? (list->set (transform-vars c-pairs))
                (list->set expected)))

(let* ([eqns (rewrite-rules (x y z)
               ((* (i x) (* x y)) -> y))]
       [expected '(((* x0 x1) . (* (i (i x0)) x1))
                   (x0 . x0))]
       [c-pairs (all-critical-pairs eqns)]
       [c-pairs (remove-duplicates
                 (for/list ([cp c-pairs])
                   (transform-vars cp (lambda (i) (var i)))))])
  (check-equal? (list->set (transform-vars c-pairs))
                (list->set expected)))
#+END_SRC

A simple example from [[citet:BaaderTermrewritingall1999][Example 6.2.2]] is given in
Listing [[all-critical-pairs-example]]:

#+NAME: all-critical-pairs-example
#+BEGIN_SRC scheme :eval yes :exports both :results output code
(let ([cpairs (all-critical-pairs
        (rewrite-rules (x y z)
          ((f (f x y) z) -> (f x (f y z)))
          ((f (i x) x)  -> e)))])
  (print-rule (map transform-vars cpairs)))
#+END_SRC

#+RESULTS: all-critical-pairs-example
#+begin_src scheme
	(f x0 (f x1 x2)) -> (f x0 (f x1 x2))
	(f (f x0 x1) (f x2 x3)) -> (f (f x0 (f x1 x2)) x3)
	(f (i x0) (f x0 x1)) -> (f e x1)
	e -> e
#+end_src

** Orderings

To start, we consider a basic cardinality-based measure on term-graphs
[[citep:HarrisonIntroductionlogicautomated2007][Chapter 4.6]].

#+ATTR_LATEX: :options [Term-graph cardinality measure]
#+NAME: term-graph-measure-based-order
#+BEGIN_definition
The order \(s > t\) is given by \(\abs{s} > \abs{t}\) for terms \(s, t \in
\mathcal{T}\) and cardinality measure \(\abs{s}\).
#+END_definition

#+NAME: term-size-function
#+BEGIN_SRC scheme :eval yes :exports code :results none :noweb-ref order-functions
(define graph-size
  (lambda (t)
    (if (var? t)
        1
        (foldl (lambda (x n)
                 (+ n (graph-size x)))
               1 (cdr t)))))
#+END_SRC

#+NAME: term-size-tests
#+BEGIN_SRC scheme :eval yes :exports none :results silent
(let ([x (var 0)]
      [y (var 1)]
      [z (var 2)])
  (check-eq? (graph-size x) 1)
  (check-eq? (graph-size `(f ,x)) 2)
  (check-eq? (graph-size `(f ,x ,y)) 3)
  (check-eq? (graph-size `(f (g ,x))) 3)
  (check-eq? (graph-size `(f (f ,x ,y) ,z)) 5))
#+END_SRC

#+NAME: term-size-order
#+BEGIN_SRC scheme :eval yes :exports none :results none :noweb-ref order-functions
(define size-gt
  (lambda (t1 t2)
    (> (graph-size t1) (graph-size t2))))
#+END_SRC

We need a *reduction order* for Knuth-Bendix completion.  The standard
cardinality measure itself will not suffice, since it is not closed under
substitutions [[citep:BaaderTermrewritingall1999][Example 5.2.2]].

An extension to the cardinality order is the strict reduction order given by
\(s > t \iff \abs{s} > \abs{t}\), \(s, t \in \mathcal{T}\) such that \(\forall x \in \mathcal{V}\),
\(\abs{s}_x \geq \abs{t}_x\), where \(\abs{t}_x\) is the number of occurrences
of \(x\) in \(t\).  However, according to
[[citet:HarrisonIntroductionlogicautomated2007]], this reduction order is not
well-suited for algebraic theories.

*** Lexicographical Path Order
Instead, we will use the standard lexicographical path order (LPO)
[[citep:BaaderTermrewritingall1999][Example 5.4.12]].

The LPO order will need an operator-symbol measure.  In other words, an
order--possibly arbitrary--is imposed on function symbols like \(*\), \(f\),
etc., considered together with their effective arities.

Our implementations roughly follow
[[citet:HarrisonIntroductionlogicautomated2007][Chapter 4.6]].

#+NAME: op-gt
#+BEGIN_SRC scheme :eval yes :exports code :results none :noweb-ref order-functions
;; Greater-than comparison of operator symbols against a given
;; ordering (implied by an ordered list containing all known operators)
;; and their arities--when applicable.
(define (op-gt op-list t1 t2)
  (cond
   [(and (symbol? t1) (symbol? t2))
    (> (length (or (member t1 op-list)
                   (error 'op-gt "op ~a not found." t1)))
       (length (or (member t2 op-list)
                   (error 'op-gt "op ~a not found." t2))))]
   [(and (list? t1) (list? t2))
    (match-let ([(cons t1-rator t1-rands) t1]
                [(cons t2-rator t2-rands) t2])
      (if (eq? t1-rator t2-rator)
          (> (length t1-rands) (length t2-rands))
          (> (length (or (member t1-rator op-list)
                         (error 'op-gt "op ~a not found." t1-rator)))
             (length (or (member t2-rator op-list)
                         (error 'op-gt "op ~a not found." t2-rator))))))]))
#+END_SRC

#+NAME: op-gt-tests
#+BEGIN_SRC scheme :eval yes :exports none :results silent
(check-true (op-gt '(+ e) '(+ 1) '(e)))
(check-true (op-gt '(e +) '(e) '(+ 1)))
(check-false (op-gt '(e +) '(+ 1) '(e)))
(check-true (op-gt '(e +) '(+ 1 2 3) '(+ 1 2)))
(check-false (op-gt '(e +) '(+ 1 2) '(+ 1 2 3)))
(check-true (op-gt '(e +) 'e '+))
(check-false (op-gt '(e +) '+ 'e))
(check-false (op-gt '(e +) '+ '+))
#+END_SRC

#+NAME: lex-order
#+BEGIN_SRC scheme :eval yes :exports code :results none :noweb-ref order-functions
;; Lexicographical extension of an order.
(define (lex-gt order t1 t2)
  (match* (t1 t2)
    [((cons t1-car t1-cdr) (cons t2-car t2-cdr))
     (if (order t1-car t2-car)
         (eq? (length t1-cdr) (length t2-cdr))
         (and (eq? t1-car t2-car)
              (lex-gt order t1-cdr t2-cdr)))]
    [(_ _) #f]))
#+END_SRC

#+NAME: lex-order-tests
#+BEGIN_SRC scheme :eval yes :exports none :results silent
(check-true (lex-gt eq? '(f) '(f)))
(check-true (lex-gt eq? '(f g) '(f g)))
(check-false (lex-gt eq? '(f g) '(f)))
(check-false (lex-gt eq? '(f) '(f g)))
#+END_SRC

#+NAME: lpo-orders
#+BEGIN_SRC scheme :eval yes :exports code :results none :noweb-ref order-functions
;; Lexicographical path order.
(define (lpo-gt op-ord t1 t2)
  ;; Constants are expressed as 0-arity functions--for consistency,
  ;; so we transform symbols that represent them into S-expressions.
  (let ([t1 (if (symbol? t1) (list t1) t1)]
        [t2 (if (symbol? t2) (list t2) t2)])
    (match* (t1 t2)
            [(_ (? var? t2))
               (and (not (eq? t1 t2))
                    ;; FIXME: Seems pretty wasteful.  Some state would be good here?
                    (set-member? (vars t1) t2))]
            [((cons t1-rator t1-rands) (cons t2-rator t2-rands))
             (or (ormap (lambda (x)
                          (or (eq? x t2)
                              (lpo-gt op-ord x t2)))
                        t1-rands)
                 (and (andmap (curry lpo-gt op-ord t1) t2-rands)
                      (or (op-ord t1-rator t2-rator)
                          (and (eq? t1-rator t2-rator)
                               (lex-gt (curry lpo-gt op-ord) t1-rands t2-rands)))))]
            [(_ _) #f])))

;; LPO's completion.
(define (lpo-ge op-ord t1 t2)
  (or (eq? t1 t2)
      (lpo-gt op-ord t1 t2)))
#+END_SRC

#+NAME: lpo-orders-tests
#+BEGIN_SRC scheme :eval yes :exports code :results silent
(check-false (lpo-gt (curry op-gt '(f g)) `(f) `(f)))
(check-true (lpo-gt (curry op-gt '(f g)) `(f) `(g)))
(check-false (lpo-gt (curry op-gt '(f g)) `(g) `(f)))
(check-false (lpo-gt (curry op-gt '(f g x)) `(f ,(var 0)) `(f x)))

(let ([x (var 0)]
      [y (var 1)]
      [z (var 2)]
      [op-gt (curry op-gt '(i f e))])
  ;; Tests from Example 5.4.13
  (check-true (lpo-gt op-gt `(i e) 'e))
  (check-true (lpo-gt op-gt `(f ,x e) x))
  (check-true (lpo-gt op-gt `(i (f ,x ,y)) `(f (i ,y) (i ,x))))
  (check-true (lpo-gt op-gt `(i (f ,x ,y)) `(i ,y)))
  (check-true (lpo-gt op-gt `(i (f ,x ,y)) `(i ,x)))
  (check-true (lpo-gt op-gt `(f (f ,x ,y) ,z) `(f ,x (f ,y ,z)))))
#+END_SRC

:TODO:
We could also implement Knuth-Bendix orderings (i.e. using weight functions).
:END:

** Completion

As we mentioned earlier, a naively derived set of rewrite rules \(R\)
(e.g. left-to-right replacements) may easily be insufficient for the purpose of
fully representing a system of equations/identities, \(\approx_{E}\), and its
logical consequences (e.g. right inverses in the group axioms).  This is where
completion comes in.

Starting with a simple set of identities, \(E_0\), and a reduction order, \(>\),
the classical approach to completion [[citep:KnuthSimplewordproblems1983]]
produces a confluent, terminating set of rewrite rules, \(R\)--when possible.
More generally, a completion procedure, \(\mathcal{C}\),
[[citep:BaaderTermrewritingall1999][Definition 7.2.3]] produces a sequence
\(\left(E_0, R_0\right) \vdash_{\mathcal{C}} \left(E_1, R_1\right) \dots \) that
may converge to \(\left(\emptyset, R_N = R\right)\) for some number of iterations,
\(N\).

Simply put, the procedure generates and normalizes critical pairs resulting from
a running set of rewrite rules and adds distinct pairs as new rewrite rules;
otherwise, it removes critical pairs that reduce to equivalent terms.  When all
the critical pairs are exhausted, the resulting rule set is confluent.

The addition of new rewrite rules derived from the generated critical pairs is
arguable the key step.  This step reflects both the intent to derive a confluent
system and the notion that a given (sub)set of rewrite rules only partially
model--syntactically--the semantics behind a set of equations.
Birkhoff's Theorem [[citep:BaaderTermrewritingall1999][Theorem 3.5.14]] gives
the connection between rewrite rules \(\mathcal{R} \subset \xleftrightarrow{*}_{E}\) and
relations \(\approx_{E}\).

*** The Basic Completion Procedure

#+NAME: normalize-and-orient
#+BEGIN_SRC scheme :eval yes :exports code :results none :noweb-ref completion-functions
;; Normalize an equation/identity according to a set of replacement rules and
;; return the car and cdr in the given term ordering.
(define (normalize-oriented ord eqs eq)
  (match eq
    [(cons s t)
     (let* ([-s (normalize eqs s)]
            [-t (normalize eqs t)]
            [s-gt-t (ord -s -t)])
       (cond
        [(boolean? s-gt-t)
         (if s-gt-t
             (cons -s -t)
             (cons -t -s))]
        [else #f]))]))
#+END_SRC

#+NAME: normalize-and-orient-tests
#+BEGIN_SRC scheme :eval yes :exports none :results silent
(let* ([ord (curry lpo-gt (curry op-gt '(* i e)))]
       [rules (fresh-forms (x y z)
                ((* e x) . x)
                ((* (* x y) z) . (* x (* y z)))
                ((* (i x) x) . e))]
       [x (var (gensym))]
       [eq-1 `(e . (* (* e ,x) (i (* e ,x))))]
       ;; We start with the standard group l ~ r identities and
       ;; normalize + orient the following: (1 * x) ~ (1 * x) * (1 * x)^{-1}.
       ;; First, this equation should reduce to the missing right inverse identity.
       ;; Second, the reduction order should be reversed (i.e. larger term to smaller term).
       [expected-1 `((* ,x (i ,x)) . e)])
  (check-equal? (normalize-oriented ord rules eq-1) expected-1))
#+END_SRC

#+NAME: basic-completion
#+BEGIN_SRC scheme :eval yes :exports code :results none :noweb-ref completion-functions
;; The basic completion algorithm with deferring for nonn-orientable equations
;; from [[citet:HarrisonIntroductionlogicautomated2007][Chapter 4.7]].
(define (-basic-completion ord eqs deferred cpairs max-iter iter)
  (if (> iter max-iter)
      (begin
        ;; (printf "reached max iters\n")
        eqs)
      (match cpairs
        [(cons cp cpairs-cdr)
         (begin
           ;; (printf "------completion-cons (~a)\ncp: " iter)
           ;; (print-eqn (list cp))
           ;; (printf "deferred: \n")
           ;; (print-rule deferred)
           ;; (printf "cpairs-cdr: \n")
           ;; (if (< (length cpairs-cdr) 20)
           ;;     (print-eqn cpairs-cdr)
           ;;     (printf "~a\n" (length cpairs-cdr)))
           ;; (printf "eqs: \n")
           ;; (if (< (length eqs) 20)
           ;;     (print-eqn eqs)
           ;;     (printf "~a\n" (length eqs)))
           (let* ([cp-normed (normalize-oriented ord eqs cp)]
                  [arg-list
                   (begin
                     ;; (printf "cp-normed: \n")
                     (if (eq? cp-normed #f)
                         (begin
                           ;; (printf "false\n")
                           ;; If orientation fails, defer the equation.
                           (list eqs (cons cp deferred) cpairs-cdr
                                 max-iter (+ 1 iter)))
                         (match-let* ([(cons -s -t) cp-normed])
                           ;; (print-eqn (list cp-normed))
                           (if (equal? -s -t)
                               (begin
                                 ;; This normalized & oriented critical pair reduces to
                                 ;; the same two terms (i.e. they're joinable), so we
                                 ;; discard it.
                                 ;; (printf "CP (i.e. cp-normed) joins\n")
                                 (list eqs deferred cpairs-cdr
                                       max-iter (+ 1 iter)))
                               ;; Since the normalized & oriented critical pair didn't join, we
                               ;; add it to our list of rewrite rules and compute the
                               ;; critical pairs resulting from it and all the other rules.
                               (let* ([new-eqs (cons cp-normed eqs)]
                                      [new-cpairs (append-map
                                                   (lambda (x)
                                                     (append
                                                      (critical-pairs cp-normed (list x))
                                                      ;; Include transposed pair
                                                      (if (not (equal? cp-normed x))
                                                          (critical-pairs x (list cp-normed))
                                                          '())))
                                                   new-eqs)])
                                 ;; (printf "new-cpairs: \n")
                                 ;; (if (< (length new-cpairs) 20)
                                 ;;     (print-eqn new-cpairs)
                                 ;;     (printf "~a\n" (length new-cpairs)))
                                 (list new-eqs deferred (set-union new-cpairs cpairs-cdr)
                                       max-iter (+ 1 iter)))))))])
             (apply -basic-completion ord arg-list)))]
        [_
         (if (eq? deferred '())
             ;; No more deferred equations, so we're done.
             eqs
             (begin
               ;; (printf "------completion-non-cons (~a)\neqs: \n" iter)
               ;; (if (< (length eqs) 20)
               ;;     (print-eqn eqs)
               ;;     (printf "~a\n" (length eqs)))
               ;; (printf "deferred: \n") (print-eqn deferred)
               ;; (printf "cpairs: \n") (if (< (length cpairs) 20)
               ;;                           (print-eqn cpairs)
               ;;                           (printf "~a\n" (length cpairs)))
               (let ([e (ormap (curry normalize-oriented ord eqs) deferred)])
                 ;; TODO: Describe condition
                 (-basic-completion ord eqs (remove e deferred) '(e) max-iter (+ 1 iter)))))])))

(define (basic-completion ord eqs [max-iter 1000] [iter 0])
  (-basic-completion ord eqs '() (remove-duplicates (all-critical-pairs eqs)) max-iter iter))
#+END_SRC

#+NAME: basic-completion-tests
#+BEGIN_SRC scheme :eval yes :exports none :results silent
(let* ([ord (curry lpo-ge (curry op-gt '(i * e)))]
       [eqns (fresh-forms (x y z)
               ((* e x) . x)
               ((* (* x y) z) . (* x (* y z)))
               ((* (i x) x) . e))]
       [res (basic-completion ord eqns)])
  (check-equal? (normalize res
                           `(* (i (* x (i x)))
                             (* (i (* (i (* (* y z) u)) y)) (i u))))
               'z))
#+END_SRC

In Listing [[basic-completion-group-example]], we run the standard completion procedure
against the group axioms in Cref:eq:group-axioms.
#+NAME: basic-completion-group-example
#+BEGIN_SRC scheme :eval yes :exports both :results output code
(let* ([ord (curry lpo-ge (curry op-gt '(i * e)))]
       [eqns (fresh-forms (x y z)
               ((* e x) . x)
               ((* (* x y) z) . (* x (* y z)))
               ((* (i x) x) . e))]
       [rules (basic-completion ord eqns)])
  (print-rule (map transform-vars rules)))
#+END_SRC

#+RESULTS: basic-completion-group-example
#+begin_src scheme
	(i (* x0 x1)) -> (* (i x1) (i x0))
	(* x0 (* x1 (* x2 (i (* x0 (* x1 x2)))))) -> e
	(* (i (* x0 x1)) x2) -> (* (i x1) (* (i x0) x2))
	(* x0 (* x1 (* x2 (* (i (* x0 (* x1 x2))) x3)))) -> x3
	(i (* (i x0) (i x1))) -> (* x1 x0)
	(i e) -> e
	(* (i (* x0 (i x1))) (* x0 x2)) -> (* x1 x2)
	(* (i e) x0) -> x0
	(* (i (* x0 (i x1))) x0) -> x1
	(* x0 (* x1 (* (i (* x0 x1)) x2))) -> x2
	(* (i (* x0 x1)) (* x0 (* x1 x2))) -> x2
	(* x0 (* (i x0) x1)) -> x1
	(i (i x0)) -> x0
	(* x0 (i x0)) -> e
	(* x0 e) -> x0
	(* (i (i x0)) x1) -> (* x0 x1)
	(* (i x0) (* x0 x1)) -> x1
	(* e x0) -> x0
	(* (* x0 x1) x2) -> (* x0 (* x1 x2))
	(* (i x0) x0) -> e
#+end_src

Listing [[basic-completion-group-rewrite-example]] applies the rewrite rules to
produce the normal form of a non-trivial term.  To fully reduce the example term, one
needs rewrite rules that cover derived properties like right-inverses and the
involution of inverses.
#+NAME: basic-completion-group-rewrite-example
#+BEGIN_SRC scheme :eval yes :exports both :results value code
(let* ([ord (curry lpo-ge (curry op-gt '(i * e)))]
       [eqns (fresh-forms (x y z)
               ((* e x) . x)
               ((* (* x y) z) . (* x (* y z)))
               ((* (i x) x) . e))]
       [rules (basic-completion ord eqns)])
  (normalize rules
             `(* (i (* x (i x)))
                 (* (i (* (i (* (* y z) u)) y)) (i u)))))
#+END_SRC

#+RESULTS: basic-completion-group-rewrite-example
#+begin_src scheme
z
#+end_src

The results of Listing [[basic-completion-group-example]] aren't the same as
[[Cref:eq:group-completion]]; this is due to redundancies that can be reduced by
interreduction.

*** Interreduction

Per [[citep:BaaderTermrewritingall1999]], a term-rewriting system is *interreduced*
when each \(r\) in \(l \to r \in R\) is irreducible in \(R\) and \(l\) is irreducible
in \(R - \{l \to r\}\).

#+NAME: interreduction
#+BEGIN_SRC scheme :eval never :exports code :results none :noweb-ref completion-functions
(define (interreduce rules [rules-rdcd '()])
  (match rules
    [(cons (cons l r) tail-rules)
     (let* ([all-rules (append rules-rdcd tail-rules)]
            ;; Attempt to reduce the left-hand side wrt. the fully reduced set
            ;; (i.e. `rules-rdc') and the remaining rules (i.e. `rules').
            [l-rdcd (normalize all-rules l)])
       ;; TODO: Would be better to use a `-normalize' that
       ;; returns `#f' when there are no replacements.
       ;; See the TODOs in those functions.
       (if (equal? l-rdcd l)
           ;; Left-hand side reduces; add this rule to the finished set
           ;; (alongside a potentially reduced right-hand side).
           (interreduce tail-rules
                        (cons
                         (cons l (normalize (append rules rules-rdcd) r))
                         rules-rdcd))
           ;; Left-hand side doesn't reduce; drop this rule and continue.
           (interreduce tail-rules rules-rdcd)))]
    [_ (reverse rules-rdcd)]))
#+END_SRC

#+NAME: interreduction-tests
#+BEGIN_SRC scheme :eval yes :exports none :results silent
(let* ([ord (curry lpo-ge (curry op-gt '(i * e)))]
       [eqns (fresh-forms (x y z)
                          ((* e x) . x)
                          ((* (* x y) z) . (* x (* y z)))
                          ((* (i x) x) . e))]
       [rules (basic-completion ord eqns)]
       [rdcd-rules (interreduce rules)])
  (print-rule (map transform-vars rdcd-rules))
  (check-equal? (list->set (map transform-vars rdcd-rules))
                (list->set '(((i (* x0 x1)) . (* (i x1) (i x0)))
                             ((i (i x0)) . x0)
                             ((i e) . e)
                             ((* x0 (i x0)) . e)
                             ((* x0 (* (i x0) x1)) . x1)
                             ((* x0 e) . x0)
                             ((* (i x0) (* x0 x1)) . x1)
                             ((* e x0) . x0)
                             ((* (i x0) x0) . e)
                             ((* (* x0 x1) x2) . (* x0 (* x1 x2)))))))
#+END_SRC


Listing [[interreduction-group-example]] applies interreduction to the completion
results of the group axioms in [[Cref:eq:group-axioms]].  After interreduction, the
results match the replacement rules in [[Cref:eq:group-completion]].
#+NAME: interreduction-group-example
#+BEGIN_SRC scheme :eval never-export :exports both :results output code :noweb strip-export
(let* ([ord (curry lpo-ge (curry op-gt '(i * e)))]
       [eqns (fresh-forms (x y z)
                          ((* e x) . x)
                          ((* (* x y) z) . (* x (* y z)))
                          ((* (i x) x) . e))]
       [rules (basic-completion ord eqns)]
       [rdcd-rules (interreduce rules)])
  (print-rule (map transform-vars rdcd-rules)))
#+END_SRC

#+RESULTS: interreduction-group-example
#+begin_src scheme
	(i (* x0 x1)) -> (* (i x1) (i x0))
	(i e) -> e
	(* x0 (* (i x0) x1)) -> x1
	(i (i x0)) -> x0
	(* x0 (i x0)) -> e
	(* x0 e) -> x0
	(* (i x0) (* x0 x1)) -> x1
	(* e x0) -> x0
	(* (* x0 x1) x2) -> (* x0 (* x1 x2))
	(* (i x0) x0) -> e
#+end_src

* Term Rewriting in miniKanren

Having demonstrated rewrite rule completion, we return to miniKanren and
reconsider the example in Listing [[mk-algebra-rewrite-example-defs]].

Instead, if we tried to reduce the example term in Listing
[[basic-completion-group-rewrite-example]] using only the same initial left-to-right
rewrite rules--this time expressed as relations--we would find that its
relational counterpart in miniKanren is also unable to reduce the term (as
expected).  We demonstrate this in Listing [[mk-algebra-rewrite-example-revisited]].

#+NAME: mk-algebra-rewrite-example-revisited
#+BEGIN_SRC scheme :eval yes :exports both :results output code :noweb strip-export
<<cp-functions>>
<<order-functions>>
<<completion-functions>>
<<mk-algebra-rewrite-example-defs>>
<<rewrite-rules-relation-macro>>

(display (pretty-format
          (run* (q) (graph-applyo reduces
                                  '(*
                                    (i (* x (i x)))
                                    (*
                                     (i (* (i (* (* y z) u)) y))
                                     (i u)))
                                  q))
          40
          #:mode 'display))
#+END_SRC

#+RESULTS: mk-algebra-rewrite-example-revisited
#+begin_src scheme
((*
  (i (* x (i x)))
  (*
   (i (* (i (* y (* z u))) y))
   (i u))))
#+end_src

Now, in Listing [[mk-algebra-completed-relation]], we try the reduction using the
completed rule set.
#+NAME: mk-algebra-completed-relation
#+BEGIN_SRC scheme :eval yes :exports code :results silent
(let* ([ord (curry lpo-ge (curry op-gt '(i * e)))]
       [eqns (fresh-forms (x y z)
                          ((* e x) . x)
                          ((* (* x y) z) . (* x (* y z)))
                          ((* (i x) x) . e))]
       [rules (map transform-vars (basic-completion ord eqns))])
  (eval `(define (reduces-completed l r)
           (rewrite-ruleso
            l r
            (x0 x1 x2 x3)
            ,@(map (lambda (x)
                     ;; XXX TODO: This won't work because every non-logic variable
                     ;; symbol needs to be quoted.
                     (match x [(cons l r) `(,l -> ,r)]))
                   rules)))))
#+END_SRC

#+NAME: mk-algebra-completed-example
#+BEGIN_SRC scheme :eval never-export :exports both :results output code :noweb strip-export
(display (pretty-format
          (run* (q) (graph-applyo reduces-completed
                                  '(*
                                    (i (* x (i x)))
                                    (*
                                     (i (* (i (* (* y z) u)) y))
                                     (i u)))
                                  q))
          40
          #:mode 'display))
#+END_SRC

:TODO:
Use the output of Listing [[basic-completion-group-example]] to generate new src_scheme{conde}
rewrite rules.

The completion procedure can be stated as a set of inference rules
[[citep:BaaderTermrewritingall1999][Figure 7.2]] and it may be possible to
implement them as relations in miniKanren.
:END:

** Identities and Rewrite Relations
The relations implemented in Listing [[mk-graph-relations]] traverse graphs and apply other relations recursively.
#+NAME: mk-graph-relations
#+BEGIN_SRC scheme :eval yes :exports code :results silent :noweb-ref graph-relations
(define lapply-anyo
  (lambda (func l-in l-out)
    (letrec ((-lapply
              (lambda (-in -out i-any)
                (conde
                 ((fresh (i-car i-cdr o-car o-cdr o-any)
                    (== -in (cons i-car i-cdr))
                    (== -out (cons o-car o-cdr))
                    (conde
                     ((func i-car o-car)
                      (== o-any #t))
                     ((== i-car o-car)
                      (== o-any i-any)))
                    (-lapply i-cdr o-cdr o-any)))
                 ((== -in '())
                  (== i-any #t)
                  (== -out -in))))))
      (-lapply l-in l-out #f))))

(define graph-applyo
  (lambda (func g-in g-out)
    (conde
     ((fresh (i-rdc)
        (func g-in i-rdc)
        (conde
         ((== i-rdc g-out))
         ((graph-applyo func i-rdc g-out)))))
     ((fresh (i-rdc)
        (lapply-anyo
         (lambda (a b) (graph-applyo func a b))
         g-in i-rdc)
        (conde
         ((== i-rdc g-out))
         ((graph-applyo func i-rdc g-out))))))))
#+END_SRC

#+NAME: mk-graph-relations-tests
#+BEGIN_SRC scheme :eval yes :exports none :results silent
<<scheme-setup>>
<<graph-relations>>

(define reduces
  (lambda (a b)
    (conde
     ((fresh (x)
        (== a `(+ ,x ,x))
        (== b `(* 2 ,x))))
     ((fresh (x)
        (== a `(exp (log ,x)))
        (== b x))))))

(define reduceo
  (lambda (a b)
    (conde
     ((fresh (r)
        (reduces a r)
        (reduceo r b)))
     ((reduces a b)))))

(check-equal? (run* (q) (reduces '(* 5 5) q))
              '())
(check-equal? (run* (q) (reduceo '(+ 5 5) q))
              '((* 2 5)))
(check-equal? (run* (q) (reduceo '(exp (log (+ 5 5))) q))
              '((+ 5 5) (* 2 5)))


(check-equal? (run* (q) (lapply-anyo reduceo '() q)) '())


(check-equal? (run* (q) (lapply-anyo reduceo '((+ 1 1)) q))
              '(((* 2 1))))

(check-equal? (run* (q) (lapply-anyo reduceo '((+ 1 1) (+ 2 2)) q))
              '(((+ 1 1) (* 2 2))
                ((* 2 1) (+ 2 2))
                ((* 2 1) (* 2 2))))

(check-equal? (run* (q) (lapply-anyo reduceo '((* 5 5) (* 2 2)) q))
              '())
(check-equal? (run* (q) (lapply-anyo reduceo '((+ 5 5) (* 2 2)) q))
              '(((* 2 5)
                 (* 2 2))))
(check-equal? (run* (q) (lapply-anyo reduceo '((* 5 5) (+ 2 2)) q))
              '(((* 5 5)
                 (* 2 2))))


(check-equal? (run* (q) (graph-applyo reduces '(* 5 5) q))
              '())

(check-equal? (run* (q) (graph-applyo reduces '(+ 5 5) q))
              '((* 2 5)))

(check-equal? (run* (q) (graph-applyo
                         reduces
                         '(+ (exp (log 5)) 5)
                         q))
              '((+ 5 5)
                (* 2 5)))

(check-equal? (list->set (run* (q) (graph-applyo
                                    reduces
                                    '(+ (+ 5 (exp (log 5))) (+ 5 5))
                                    q)))
              (list->set '((+ (+ 5 (exp (log 5))) (* 2 5))
                           (+ (+ 5 5) (+ 5 5)) (* 2 (+ 5 5))
                           (+ (+ 5 5) (* 2 5)) (+ (+ 5 5) (* 2 5))
                           (+ (* 2 5) (* 2 5)) (* 2 (* 2 5)) (+ (* 2 5) (* 2 5))
                           (* 2 (* 2 5)) (+ (* 2 5) (+ 5 5)) (* 2 (* 2 5))
                           (+ (+ 5 5) (* 2 5)) (+ (* 2 5) (+ 5 5)) (+ (* 2 5) (* 2 5))
                           (* 2 (* 2 5)) (+ (* 2 5) (* 2 5)) (+ (* 2 5) (* 2 5))
                           (* 2 (* 2 5)) (+ (* 2 5) (* 2 5)) (* 2 (* 2 5))
                           (* 2 (* 2 5)) (+ (* 2 5) (* 2 5)) (+ (* 2 5) (* 2 5))
                           (* 2 (* 2 5)) (* 2 (* 2 5)))))

(check-equal? (run* (q) (graph-applyo
                         reduces
                         '(+ (exp (log 5)) 5)
                         '(+ 5 5)))
              '(_.0))

(check-equal? (run 5 (q) (graph-applyo reduces q 5))
              '((exp (log 5))
                (exp (log (exp (log 5))))
                (exp (log (exp (log (exp (log 5))))))
                (exp (log (exp (log (exp (log (exp (log 5))))))))
                (exp (exp (log (log 5))))))

(check-equal? (run 5 (q)
                   (fresh (r)
                     (graph-applyo reduces q `(* 2 ,r))))
              '((+ _.0 _.0)
                (exp (log (* 2 _.0)))
                (exp (log (+ _.0 _.0)))
                (exp (log (exp (log (* 2 _.0)))))
                (+ (+ _.0 _.0) (+ _.0 _.0))))
#+END_SRC

** Critcial Pair Relations
:TODO:
How could we formulate a relation for critical pairs?
Start from the DEDUCE rule?
:END:

* Discussion

Some open questions arising from this material:
- In this way, it may also be possible to produce the completion sequence, \(\left(E_i, R_i\right)\), as a goal stream
and perhaps make productive use of lazily evaluated, non-terminating/convergent
sequences.  **In other words, can a miniKanren implementation of the inference
rules produce on-line/streaming completion?**

:TODO:
- Summarize results
- Describe future work
- etc.
:END:

#+BIBLIOGRAPHY: ../tex/mk-term-rewriting.bib
#+BIBLIOGRAPHYSTYLE: plainnat

# Local Variables:
# geiser-scheme-implementation: racket
# eval: (cl-loop for x in '(rewrite-rules fresh match*) do (put x 'scheme-indent-function 1))
# End:
