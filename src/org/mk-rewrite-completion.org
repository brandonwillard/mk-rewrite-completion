#+TITLE: Knuth-Bendix Completion in miniKanren
#+AUTHOR: Brandon T. Willard
#+DATE: 2019-03-28
#+EMAIL: brandonwillard@gmail.com

#+STARTUP: hideblocks indent hidestars
#+OPTIONS: author:t date:t ^:nil toc:nil title:t tex:t d:(not "logbook" "todo" "notes")
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport

#+PROPERTY: header-args :eval never :exports both :results output drawer replace :noweb yes
#+PROPERTY: header-args+ :session mk-rewrites

#+SETUPFILE: latex-setup.org
# #+INCLUDE: org-setup.el

#+BEGIN_abstract
An investigation into the use of the Knuth-Bendix completion algorithm in
miniKanren.
#+END_abstract

* Introduction

Consider the following subset of group axiom identities--specifically, inverse elements,
identity elements, and associativity:
\begin{equation}
  \begin{aligned}
    1 \cdot x &= x
    \\
    x^{-1} \cdot x &= 1
    \\
    (x \cdot y) \cdot z &= x \cdot (y \cdot z)
  \;.
  \end{aligned}
  \label{eq:group-axioms}
\end{equation}


In miniKanren [[citep:ByrdRelationalProgrammingminiKanren2009]], we can produce
a uni-directional rewrite relation based on [[Cref:eq:group-axioms]] as
follows:
#+NAME: mk-algebra-rewrite-example-defs
#+BEGIN_SRC scheme :eval yes :exports code :results silent :noweb strip-export
<<scheme-setup>>
<<rewrite-functions>>
<<graph-relations>>

(define reduces
  (lambda (a b)
    (conde
     ((fresh (x)
        (== a `(* 1 ,x))
        (== b x)))
     ((fresh (x)
        (== a `(* (i ,x) ,x))
        (== b 1)))
     ((fresh (x y z)
        (== a `(* (* ,x ,y) ,z))
        (== b `(* ,x (* ,y ,z))))))))
#+END_SRC

When accompanied by a relation, src_scheme{graph-applyo}, that traverses forms,
reduction relations will produce every applicable reduction--as shown in
[[mk-algebra-rewrite-example-1]].
If the rewrite rules adhere to a reduction order, then we may be able to
identify some normal forms in the output (e.g. src_scheme{1}).  Otherwise, we
find intermediate reductions in the output of [[mk-algebra-rewrite-example-1]],
which implicitly show the src_scheme{conde} branches that produced successful
goals in src_scheme{reduces}.
#+NAME: mk-algebra-rewrite-example-1
#+BEGIN_SRC scheme :eval yes :exports both :results output code :noweb strip-export
(display (pretty-format
          (run* (q) (graph-applyo reduces '(* (* (i x) x) y) q))
          25
          #:mode 'display))
#+END_SRC

#+RESULTS: mk-algebra-rewrite-example-1
#+begin_src scheme
((* (i x) (* x y))
 (* 1 y)
 y)
#+end_src

In [[mk-algebra-rewrite-example-defs]] we only considered the rewrite rules implied
by left-to-right substitutions in the more general equations of
[[Cref:eq:group-axioms]].  Outside of the miniKanren context and under the
same rewrite rules, we obtain the following normal form for \((x^{-1} \cdot x) \cdot y\)
through repeated application of the same rewrite rules in order (see
[[citep:HarrisonIntroductionlogicautomated2007][Chapter 4.7]] and
[[citep:BaaderTermrewritingall1999][Chapter 1]]):.
#+NAME: group-normalize-order-1-example
#+BEGIN_SRC scheme :eval yes :exports both :results value code :noweb strip-export
<<scheme-setup>>
<<rewrite-functions>>

(let ([rules (rewrite-rules (x y z)
                            ((* (* x y) z) -> (* x (* y z)))
                            ((* 1 x) -> x)
                            ((* (i x) x) -> 1))])
  (normalize '(* (* (i x) x) y) rules))
#+END_SRC

#+RESULTS: group-normalize-order-1-example
#+begin_src scheme
y
#+end_src

It just so happens that our left-to-right rewrite rule interpretation of [[Cref:eq:group-axioms]]
does reduce terms, and--as a result--can produce normal forms.

Now, consider the normal form for \((x \cdot x^{-1}) \cdot y\); as with our
example above, it should be \(y\).  Our naively derived rewrite
rules will not produce the expected normal form, because the identity \(x \cdot
x^{-1}\) is not present--although it is implied by [[Cref:eq:group-axioms]].

Unfortunately, the addition of new rewrite rules to compensate for this
deficiency can easily remove any reducibility guarantees afforded by our original set
of rules.  For instance, if we add commutativity \(x \cdot y \to y \cdot x\), even
in more restricted forms, we will produce a non-terminating rewrite system.

In a more general context, we need a means of automatically deriving rewrite
rules with normalization and confluence guarantees.  These properties are also required
for type checking relations and other rewrite-driven operations that,
say, determine the validity of statements like "Is \(x \cdot x^{-1} = 1\) also
true/valid under [[Cref:eq:group-axioms]]?".  Knuth-Bendix completion is one such
approach, and it works by producing a set of "complete" rewrite rules for a
given set of equations.

For example, a complete set of rewrite rules for [[Cref:eq:group-axioms]] is given
by the following:
\begin{equation}
  \begin{aligned}
    1 \cdot x &\to x
    \\
    x^{-1} \cdot x &\to 1
    \\
    (x \cdot y) \cdot z &\to x \cdot (y \cdot z)
    \\
    x^{-1} \cdot (x \cdot y) &\to y
    \\
    1^{-1} &\to 1
    \\
    x \cdot 1 &\to x
    \\
    (x^{-1})^{-1} &\to x
    \\
    x \cdot x^{-1} &\to 1
    \\
    x \cdot (x^{-1} \cdot y) &\to y
    \\
    (x \cdot y)^{-1} &\to y^{-1} x^{-1}
  \;.
  \end{aligned}
\label{eq:group-completion}
\end{equation}

The rewrite rules in [[Cref:eq:group-completion]] can be produced mechanically from
[[Cref:eq:group-axioms]]--and a generic reduction order--using Knuth-Bendix
completion (e.g. Huet's procedure).  As we can see, the commutative inverse
identity (i.e. \(x^{-1} \cdot x = x \cdot x^{-1}\)) is present in a form that
preserves termination, along with other important rewrites that we might have
easily missed when attempting to manually produce a complete set of rules.


miniKanren implements a complete search [[citep:HemannSimpleCompleteSearch2018,
Hemannsmallembeddinglogic2016]], which alongside lazily evaluated results, can
be used to obtain all possible reductions under the fully enumerated set of
possible replacement rules implied by a set of equations.  However, this
approach produces infinite goal streams and only moves the standard
term-rewriting normal-form and termination concerns to the callers of said
relations.

Additionally, there are performance issues that result from the inherently large
search spaces induced by such relations.  Every matching src_scheme{conde}
clause that does not produce a normal form is essentially a wasted step.  The completions
produced by Knuth-Bendix procedures can guarantee--via (local) coherence--that
every successful unification ultimately leads to a normal form.
Likewise, some refinements [[citep:Metivierrewritingsystemsproduced1983]] of
these completion procedures are able to reduce the number of reduction rules and
quite possibly the number of redundant src_scheme{conde} clauses/unifications.


Toward the same ends, some of these issues can be mitigated through alterations
to the search process [[citep:SwordsGuidedSearchminiKanren, ZhangNeuralGuidedConstraint2018, BoskinSurprisinglyCompetitiveConditional2018]].
These approaches tend to introduce more opportunities to unknowingly violate the
relational paradigm upon which miniKanren capitalizes, but--more
importantly--they can require a distinct effort from the developer to provide
context-dependent logic that actually *does* improve the search.
In some circumstances, that logic will necessarily overlap with the aims of
term-rewriting completion described here.

For an important set of situations, we can use standard term rewriting
automations that do not involving alterations to the underlying mechanics of
miniKanren's search--or its fundamental relations/goals--and are able to provide
improvements to the specification and application of relational identities that
produce term rewriting systems.


** Notation and Implementations

In what follows, we will use \(\mathcal{R}\) to represent a set of rewrite rules
and \(\mathcal{T}\left(\mathcal{F}, \mathcal{V}\right)\) as a set of terms
derived from a set of function symbols \(\mathcal{F}\) and variables
\(\mathcal{V}\).  These are combined to form a term rewriting system
\(\left(\mathcal{R}, \mathcal{R}\right)\).

Throughout, we will use Racket to implement the term rewriting mechanics and
miniKanren implementations.

#+NAME: kanren-requires
#+BEGIN_SRC scheme :eval yes :exports code :results silent :noweb-ref scheme-setup
(require rackunit)
(require racket/pretty)
(require minikanren)

;; Include un-`provided` core functions.
(require/expose minikanren/minikanren (unify var var? reify walk*))
#+END_SRC

The macros in [[rewrite-macros]] make it easier to specify a set of rewrite
rules through the following syntax:
#+NAME: rewrite-macro-usage
#+BEGIN_SRC scheme :eval never :exports code :results none
(rewrite-rules (x y)
               ((f (g x x) y) -> (g x y))
               ((g x y) -> x))
#+END_SRC

Listing [[rewrite-macro-usage]] expands to the following:
#+NAME: rewrite-macro-expanded
#+BEGIN_SRC scheme :eval never :exports code :results none
'(list
  (let ((xv `((x unquote (var (gensym)))
              (y unquote (var (gensym))))))
    (subs-var xv '((f (g x x) y) g x y)))
  (let ((xv `((x unquote (var (gensym)))
              (y unquote (var (gensym))))))
    (subs-var xv '((g x y) . x))))
#+END_SRC

#+ATTR_LATEX: :float t :placement h!
#+CAPTION:
#+NAME: rewrite-macros
#+BEGIN_SRC scheme :eval yes :exports code :results none :noweb-ref rewrite-functions
(define (subs-var xv v)
  (match v
    [(cons h t)
     (cons (subs-var xv h) (subs-var xv t))]
    [_
     (let* ([r-pair (assoc v xv)])
       (if r-pair
           (cdr r-pair)
           v))]))

(define-syntax (rewrite-rules stx)
  (syntax-case stx (->)
    [(_ (x ...) (l -> r) ...)
     #`(list
        (let ([xv `((x . ,(var (gensym))) ...)])
          (subs-var xv (quote (l . r)))) ...)]))
#+END_SRC

#+NAME: rewrite-macros-tests
#+BEGIN_SRC scheme :eval yes :exports none :results silent
(check-true (let ([q (car (rewrite-rules (x y) (x -> x)))])
              (eq? (car q) (cdr q))))
#+END_SRC

The functions in Listing [[rewrite-helper-functions]] apply rewrite rules to a form.
src_scheme{normalize} attempts to produce a fixed-point/normalized result through
repeated application of the rewrite rules.
#+ATTR_LATEX: :float t :placement h!
#+CAPTION:
#+NAME: rewrite-helper-functions
#+BEGIN_SRC scheme :eval yes :exports code :results none :noweb-ref rewrite-functions
;; Apply a single rewrite rule or `#f`.
(define rewrite-1
  (lambda (t lr)
    (let* ([l (car lr)]
           [r (cdr lr)]
           [θ (if (not (var? t))
                  (unify t l '())
                  #f)]
           [t-new (if (eq? θ #f)
                      #f
                      (walk* r θ))])
      t-new)))

;; Apply the first rewrite rule that unifies; return `#f` otherwise.
(define rewrite
  (lambda (t rules)
    (ormap (curry rewrite-1 t) rules)))

;; Apply rewrite rules until a fixed-point is reached.
(define normalize
  (lambda (t rules)
    (cond
     [(list? t)
      (let* ([t-car (car t)]
             [t-cdr (cdr t)]
             [t-cdr-new (for/list ([a t-cdr])
                          (normalize a rules))])
        (if (eq? t-cdr-new #f)
            t
            (let* ([t-new (cons t-car t-cdr-new)]
                   [t-new-new (rewrite t-new rules)])
              (if (eq? t-new-new #f)
                  t-new
                  (normalize t-new-new rules)))))]
     [else t])))
#+END_SRC

#+NAME: rewrite-helper-functions-tests
#+BEGIN_SRC scheme :eval yes :exports none :results silent
(check-equal? (rewrite '(f x y)
                       (let ([q (var 0)]
                             [w (var 1)])
                         `(((g ,q ,w) . ,w)
                           ((i) . 1))))
              #f)
(check-equal? (rewrite '(g x (i))
                       (let ([q (var 0)]
                             [w (var 1)])
                         `(((g ,q ,w) . ,w)
                           ((i) . 1))))
              '(i))

(check-equal? (normalize '(g (f i) (i))
                         (let ([q (var 0)]
                               [w (var 1)]
                               [z (var 2)])
                           `(((g ,q ,w) . ,w)
                             ((f ,z) . ,z)
                             ((i) . 1))))
              1)
(check-equal? (normalize '(g (f (i)) (i))
                         (let ([q (var 0)]
                               [w (var 1)]
                               [z (var 2)])
                           `(((g ,q ,w) . (+ ,q ,w))
                             ((f ,z) . ,z)
                             ((i) . 1))))
              '(+ 1 1))
#+END_SRC

* Rewrite Rule Completion
** Critical Pairs
Following [[citet:BaaderTermrewritingall1999]] Definition 6.2.1,
#+ATTR_LATEX: :options [Critical Pairs]
#+BEGIN_definition
For \(l_i \to r_i\), \(i \in \left\{1, 2\right\}\) with
\(\bigcap_{i \in \left\{1, 2\right\}} \operatorname{Vars}\left(l_i, r_i\right) = \emptyset\),
let \(p \in \operatorname{Pos}\left(l_1\right)\) and \(\theta\) a most general
unifier of \(l_1 \mid_{p} =^{?} l_2\) s.t. \(l_1 \mid_{p}\) is not a variable, then
\(l_i \to r_i\) determine a *critical pair*
\({\langle \theta r_1, \left(\theta l_1\right)\left[\theta r_2\right]_p \rangle}\).
#+END_definition

The functions in Listing [[critical-pairs-functions]] compute the critical pairs between
two rewrite rules.
#+NAME: critical-pairs-functions
#+BEGIN_SRC scheme :eval yes :exports code :results none :noweb-ref cp-functions
;; Compute critical pairs for sub-terms of a compound term graph.
(define critical-pairs-cons
  (lambda (l r l2 r2)
    (cond
     [(cons? l)
      (let* ([l-car (car l)]
             [l-cdr (cdr l)]
             [θ (if (not (var? l-car))
                    (unify l-car l2 '())
                    #f)]
             [cps (if (eq? θ #f)
                      '()
                      (list (cons (walk* r θ)
                                  (walk* (cons r2 l-cdr) θ))))]
             [cps (append (for/list ([h (critical-pairs-cons l-car r l2 r2)])
                            (cons (car h) (cons (cdr h) l-cdr))) cps)]
             [cps (append (for/list ([t (critical-pairs-cons l-cdr r l2 r2)])
                            (cons (car t) (cons l-car (cdr t)))) cps)])
        cps)]
     [else '()])))

;; Compute critical pairs for an arbitrary term graph.
(define critical-pairs
  (lambda (l r l2 r2)
    (if (var? l)
        '()
        (let ([θ (unify l l2 '())]
              [cps '()])
          (unless (eq? θ #f)
            (set! cps (cons `(,(walk* r θ) . ,(walk* r2 θ)) cps)))
          (when (cons? l)
            (set! cps (append (critical-pairs-cons l r l2 r2) cps)))
          cps))))
#+END_SRC

A simple example from [[citet:BaaderTermrewritingall1999][Example 6.2.2]] is given in
Listing [[critical-pairs-examples]]:
#+NAME: critical-pairs-examples
#+BEGIN_SRC scheme :eval yes :exports both :results value code
(let ([x (var 0)]
      [y (var 1)]
      [z (var 2)]
      [x1 (var 3)])
  (critical-pairs `(f (f ,x ,y) ,z) ; ->
                  `(f ,x (f ,y ,z))
                  `(f (i ,x1) ,x1) ; ->
                  'e))
#+END_SRC

#+RESULTS: critical-pairs-examples
#+begin_src scheme
(((f (i #(3)) (f #(3) #(2))) f e #(2)))
#+end_src

The function in Listing [[all-critical-pairs]] computes all critical pairs between a
set of rewrite rules.
#+NAME: all-critical-pairs
#+BEGIN_SRC scheme :eval yes :exports code :results none :noweb-ref cp-functions
(define (all-critical-pairs rules)
  (let ([c-pairs '()])
    (for/list ([r (in-combinations rules 2)])
      (let* ([rule1 (car r)]
             [rule2 (cadr r)]
             [l (car rule1)]
             [r (cdr rule1)]
             [l2 (car rule2)]
             [r2 (cdr rule2)])
        (set! c-pairs (append (critical-pairs l r l2 r2) c-pairs))))
    c-pairs))
#+END_SRC

#+NAME: all-critical-pairs-example
#+BEGIN_SRC scheme :eval yes :exports both :results value code
(all-critical-pairs
 (rewrite-rules (x y z)
                ((f (f x y) z) -> (f x (f y z)))
                ((f (i x) x)  -> e)))
#+END_SRC

#+RESULTS: all-critical-pairs-example
#+begin_src scheme
(((f (i #(g4520)) (f #(g4520) #(g4519))) f e #(g4519)))
#+end_src

#+RESULTS: critical-pairs-tests
#+BEGIN_SRC scheme :eval yes :exports none :results silent
(let* ([x (var 0)]
       [x1 (var 1)]
       [x2 (var 2)]
       [y (var 3)]
       [y1 (var 4)]
       [y2 (var 5)]
       [rules `(((+ (s ,x) ,y) . ; ->
                 (s (+ ,x ,y)))
                ((+ ,x1 (s ,y1)) . ; ->
                 (s (+ ,x1 ,y1)))
                ((+ ,x2 ,y2) . ; ->
                 (+ ,y2 ,x2)))]
       [c-pairs (all-critical-pairs rules)])
  (check-equal? c-pairs
                `(((s (+ ,x2 ,y1)) + (s ,y1) ,x2)
                  ((s (+ ,x ,y2)) + ,y2 (s ,x))
                  ((s (+ ,x (s ,y1))) s (+ (s ,x) ,y1)))))
#+END_SRC

** Orderings

To start, we consider a basic cardinality-based measure on term-graphs
[[citep:HarrisonIntroductionlogicautomated2007][Chapter 4.6]].

#+ATTR_LATEX: :options [Term-graph cardinality measure]
#+NAME: term-graph-measure-based-order
#+BEGIN_definition
The order \(s > t\) is given by \(\abs{s} > \abs{t}\) for terms \(s, t \in
\mathcal{T}\) and cardinality measure \(\abs{s}\).
#+END_definition

#+NAME: term-size-function
#+BEGIN_SRC scheme :eval yes :exports code :results none :noweb-ref order-functions
(define graph-size
  (lambda (t)
    (if (var? t)
        1
        (foldl (lambda (x n)
                 (+ n (graph-size x)))
               1 (cdr t)))))
#+END_SRC

#+NAME: term-size-tests
#+BEGIN_SRC scheme :eval yes :exports none :results silent
(let ([x (var 0)]
      [y (var 1)]
      [z (var 2)])
  (check-eq? (graph-size x) 1)
  (check-eq? (graph-size `(f ,x)) 2)
  (check-eq? (graph-size `(f ,x ,y)) 3)
  (check-eq? (graph-size `(f (g ,x))) 3)
  (check-eq? (graph-size `(f (f ,x ,y) ,z)) 5))
#+END_SRC

#+NAME: term-size-order
#+BEGIN_SRC scheme :eval yes :exports none :results none :noweb-ref order-functions
(define size-gt
  (lambda (t1 t2)
    (> (graph-size t1) (graph-size t2))))
#+END_SRC

We need a *reduction order* for Knuth-Bendix completion.  The standard
cardinality measure itself will not suffice, since it is not closed under
substitutions [[citep:BaaderTermrewritingall1999][Example 5.2.2]].

An extension to the cardinality order is the strict reduction order given by
\(s > t \iff \abs{s} > \abs{t}\), \(s, t \in \mathcal{T}\) such that \(\forall x \in \mathcal{V}\),
\(\abs{s}_x \geq \abs{t}_x\), where \(\abs{t}_x\) is the number of occurrences
of \(x\) in \(t\).  However, according to
[[citet:HarrisonIntroductionlogicautomated2007]], this reduction order is not
well-suited for algebraic theories.

*** Lexicographical Path Order
Instead, we will use the standard lexicographical path order (LPO)
[[citep:BaaderTermrewritingall1999][Example 5.4.12]].

First, some helper functions.
#+NAME: vars-helper
#+BEGIN_SRC scheme :eval yes :exports code :results none :noweb-ref order-functions
;; Returns all the variables in a term graph.
(define vars
  (lambda (x [s (set)])
    (cond
     [(pair? x)
      (set-union (vars (car x))
                 (vars (cdr x)))]
     [(var? x)
      (set-add s x)]
     [else s])))
#+END_SRC

#+NAME: vars-helper-tests
#+BEGIN_SRC scheme :eval yes :exports none :results silent
(let ([v0 (var 0)]
      [v1 (var 1)]
      [v2 (var 2)]
      [v3 (var 3)]
      [v4 (var 4)])
  (check-equal?
   (vars `(f (g ,v0 x (,v0 ,v2 ,v3)) ,v1 (h (j (k ,v4) ,v3))))
   (set v1 v3 v0 v4 v2)))
#+END_SRC

The LPO order will need an operator-symbol measure.  In other words, an
order--possibly arbitrary--is imposed on function symbols like \(*\), \(f\),
etc., considered together with their effective arities.

Our implementations roughly follow
[[citet:HarrisonIntroductionlogicautomated2007][Chapter 4.6]].

#+NAME: op-gt
#+BEGIN_SRC scheme :eval yes :exports code :results none :noweb-ref order-functions
;; Greater-than comparison of operator symbols against a given
;; ordering (implied by an ordered list containing all known operators)
;; and their arities--when applicable.
(define op-gt
  (lambda (op-list t1 t2)
    (cond
     [(and (symbol? t1) (symbol? t2))
      (> (length (or (member t1 op-list)
                     (error 'op-gt "op ~a not found." t1)))
         (length (or (member t2 op-list)
                     (error 'op-gt "op ~a not found." t2))))]
     [(and (list? t1) (list? t2))
      (let ([t1-rator (car t1)]
            [t1-rands (cdr t1)]
            [t2-rator (car t2)]
            [t2-rands (cdr t2)])
        (if (eq? t1-rator t2-rator)
            (> (length t1-rands) (length t2-rands))
            (> (length (or (member t1-rator op-list)
                           (error 'op-gt "op ~a not found." t1-rator)))
               (length (or (member t2-rator op-list)
                           (error 'op-gt "op ~a not found." t2-rator))))))])))
#+END_SRC

#+NAME: op-gt-tests
#+BEGIN_SRC scheme :eval yes :exports none :results silent
(check-true (op-gt '(+ e) '(+ 1) '(e)))
(check-true (op-gt '(e +) '(e) '(+ 1)))
(check-false (op-gt '(e +) '(+ 1) '(e)))
(check-true (op-gt '(e +) '(+ 1 2 3) '(+ 1 2)))
(check-false (op-gt '(e +) '(+ 1 2) '(+ 1 2 3)))
(check-true (op-gt '(e +) 'e '+))
(check-false (op-gt '(e +) '+ 'e))
(check-false (op-gt '(e +) '+ '+))
#+END_SRC

#+NAME: lex-order
#+BEGIN_SRC scheme :eval yes :exports code :results none :noweb-ref order-functions
;; Lexicographical extension of an order.
(define lex-gt
  (lambda (order t1 t2)
    (if (and (pair? t1) (pair? t2))
        (let ([t1-car (car t1)]
              [t1-cdr (cdr t1)]
              [t2-car (car t2)]
              [t2-cdr (cdr t2)])
          (if (order t1-car t2-car)
           (eq? (length t1-cdr) (length t2-cdr))
           (and (eq? t1-car t2-car)
                (lex-eq order t1-cdr t2-cdr))))
        #f)))
#+END_SRC

#+NAME: lex-order-tests
#+BEGIN_SRC scheme :eval yes :exports none :results silent
(check-true (lex-gt eq? '(f) '(f)))
(check-true (lex-gt eq? '(f g) '(f g)))
(check-false (lex-gt eq? '(f g) '(f)))
(check-false (lex-gt eq? '(f) '(f g)))
#+END_SRC

#+NAME: lpo-orders
#+BEGIN_SRC scheme :eval yes :exports code :results none :noweb-ref order-functions
;; Lexicographical path order.
(define lpo-gt
  (lambda (op-ord t1 t2)
    ;; Constants are expressed as 0-arity functions--for consistency,
    ;; so we transform symbols that represent them into S-expressions.
    (let ([t1 (if (symbol? t1)
                  (list t1)
                  t1)]
          [t2 (if (symbol? t2)
                  (list t2)
                  t2)])
      (cond
       [(var? t2)
        (and (not (eq? t1 t2))
             ;; FIXME: Seems pretty wasteful.  Some state would be good here?
             (set-member? (vars t1) t2))]
       ;; TODO: Ugh, just use `match' already!
       [(and (list? t1) (list? t2))
        (let ([t1-rator (car t1)]
              [t2-rator (car t2)]
              [t1-rands (cdr t1)]
              [t2-rands (cdr t2)])
          (or (ormap (lambda (x)
                       (or (eq? x t2)
                           (lpo-gt op-ord x t2)))
                     t1-rands)
              (and (andmap (curry lpo-gt op-ord t1) t2-rands)
                   (or (op-ord t1-rator t2-rator)
                       (and (eq? t1-rator t2-rator)
                            (lex-gt (curry lpo-gt op-ord) t1-rands t2-rands))))))]
       [else #f]))))

;; LPO's completion.
(define lpo-ge
  (lambda (op-ord t1 t2)
    (or (eq? t1 t2)
        (lpo-gt op-ord t1 t2))))
#+END_SRC

#+NAME: lpo-orders-tests
#+BEGIN_SRC scheme :eval yes :exports code :results none
;; (require debug/repl)
;; Use `(debug-repl)` and `(resume)'.

(check-false (lpo-gt (curry op-gt '(f g)) `(f) `(f)))
(check-true (lpo-gt (curry op-gt '(f g)) `(f) `(g)))
(check-false (lpo-gt (curry op-gt '(f g)) `(g) `(f)))
(check-false (lpo-gt (curry op-gt '(f g x)) `(f ,(var 0)) `(f x)))

(let ([x (var 0)]
      [y (var 1)]
      [z (var 2)]
      [op-gt (curry op-gt '(i f e))])
  ;; Tests from Example 5.4.13
  (check-true (lpo-gt op-gt `(i e) 'e))
  (check-true (lpo-gt op-gt `(f ,x e) x))
  (check-true (lpo-gt op-gt `(i (f ,x ,y)) `(f (i ,y) (i ,x))))
  (check-true (lpo-gt op-gt `(i (f ,x ,y)) `(i ,y)))
  (check-true (lpo-gt op-gt `(i (f ,x ,y)) `(i ,x)))
  (check-true (lpo-gt op-gt `(f (f ,x ,y) ,z) `(f ,x (f ,y ,z)))))
#+END_SRC

:NOTES:
We could also implement Knuth-Bendix orderings (i.e. using weight functions).
:END:

** Completion
*** Huet's Completion Procedure

#+NAME: cp-completion
#+BEGIN_SRC scheme :eval yes :exports code :results none :noweb-ref completion-functions
(define huet-completion
  (lambda (idents ord)
    ()))
#+END_SRC

* miniKanren Integrations

Certain uses of miniKanren reflect term-rewriting in such a way as to benefit
from the rewrite rule completion.

In the miniKanren DSL, constructs like src_scheme{conde} can implicitly specify a set of
rewrite rules \(\mathcal{R}\).  The general pattern of these rules is given by the
following:
#+ATTR_LATEX: :float t :placement h!
#+CAPTION:
#+NAME: conde-pattern-form
#+BEGIN_SRC scheme :eval never :results none :exports src
(fresh (l r)
  (conde
   ;; l_1 -> r_1
   ((== l L1)
    (== r R1))
   ;; l_2 -> r_2
   ((== l L2)
    (== r R2))
   ;;...
   ))
#+END_SRC

When the src_scheme{conde} forms are intercepted by a macro, one can parse the
branches and extract implicit rewrite rules.  This step could be performed in an
operator specifically for defining rewrite rules, or as a generalized miniKanren
"compilation" step that reasons about arbitrary forms in the unevaluated
miniKanren DSL (e.g. traverse src_scheme{fresh} and src_scheme{conde} forms for
potential \(l_i \to r_i\) rules).

** Graph Relations
The relations implemented here traverse graphs and apply other relations recursively.
#+NAME: mk-graph-relations
#+BEGIN_SRC scheme :eval yes :exports none :results silent :noweb-ref graph-relations
(define lapply-anyo
  (lambda (func l-in l-out)
    (letrec ((-lapply
              (lambda (-in -out i-any)
                (conde
                 ((fresh (i-car i-cdr o-car o-cdr o-any)
                    (== -in (cons i-car i-cdr))
                    (== -out (cons o-car o-cdr))
                    (conde
                     ((func i-car o-car)
                      (== o-any #t))
                     ((== i-car o-car)
                      (== o-any i-any)))
                    (-lapply i-cdr o-cdr o-any)))
                 ((== -in '())
                  (== i-any #t)
                  (== -out -in))))))
      (-lapply l-in l-out #f))))

(define graph-applyo
  (lambda (func g-in g-out)
    (conde
     ((fresh (i-rdc)
        (func g-in i-rdc)
        (conde
         ((== i-rdc g-out))
         ((graph-applyo func i-rdc g-out)))))
     ((fresh (i-rdc)
        (lapply-anyo
         (lambda (a b) (graph-applyo func a b))
         g-in i-rdc)
        (conde
         ((== i-rdc g-out))
         ((graph-applyo func i-rdc g-out))))))))

#+END_SRC

#+NAME: mk-graph-relations-tests
#+BEGIN_SRC scheme :eval yes :exports none :results silent
<<scheme-setup>>
<<graph-relations>>

(define reduces
  (lambda (a b)
    (conde
     ((fresh (x)
        (== a `(+ ,x ,x))
        (== b `(* 2 ,x))))
     ((fresh (x)
        (== a `(exp (log ,x)))
        (== b x))))))

(define reduceo
  (lambda (a b)
    (conde
     ((fresh (r)
        (reduces a r)
        (reduceo r b)))
     ((reduces a b)))))

(check-equal? (run* (q) (reduces '(* 5 5) q))
              '())
(check-equal? (run* (q) (reduceo '(+ 5 5) q))
              '((* 2 5)))
(check-equal? (run* (q) (reduceo '(exp (log (+ 5 5))) q))
              '((+ 5 5) (* 2 5)))


(check-equal? (run* (q) (lapply-anyo reduceo '() q)) '())


(check-equal? (run* (q) (lapply-anyo reduceo '((+ 1 1)) q))
              '(((* 2 1))))

(check-equal? (run* (q) (lapply-anyo reduceo '((+ 1 1) (+ 2 2)) q))
              '(((+ 1 1) (* 2 2))
                ((* 2 1) (+ 2 2))
                ((* 2 1) (* 2 2))))

(check-equal? (run* (q) (lapply-anyo reduceo '((* 5 5) (* 2 2)) q))
              '())
(check-equal? (run* (q) (lapply-anyo reduceo '((+ 5 5) (* 2 2)) q))
              '(((* 2 5)
                 (* 2 2))))
(check-equal? (run* (q) (lapply-anyo reduceo '((* 5 5) (+ 2 2)) q))
              '(((* 5 5)
                 (* 2 2))))


(check-equal? (run* (q) (graph-applyo reduces '(* 5 5) q))
              '())

(check-equal? (run* (q) (graph-applyo reduces '(+ 5 5) q))
              '((* 2 5)))

(check-equal? (run* (q) (graph-applyo
                         reduces
                         '(+ (exp (log 5)) 5)
                         q))
              '((+ 5 5)
                (* 2 5)))

(check-equal? (list->set (run* (q) (graph-applyo
                                    reduces
                                    '(+ (+ 5 (exp (log 5))) (+ 5 5))
                                    q)))
              (list->set '((+ (+ 5 (exp (log 5))) (* 2 5))
                           (+ (+ 5 5) (+ 5 5)) (* 2 (+ 5 5))
                           (+ (+ 5 5) (* 2 5)) (+ (+ 5 5) (* 2 5))
                           (+ (* 2 5) (* 2 5)) (* 2 (* 2 5)) (+ (* 2 5) (* 2 5))
                           (* 2 (* 2 5)) (+ (* 2 5) (+ 5 5)) (* 2 (* 2 5))
                           (+ (+ 5 5) (* 2 5)) (+ (* 2 5) (+ 5 5)) (+ (* 2 5) (* 2 5))
                           (* 2 (* 2 5)) (+ (* 2 5) (* 2 5)) (+ (* 2 5) (* 2 5))
                           (* 2 (* 2 5)) (+ (* 2 5) (* 2 5)) (* 2 (* 2 5))
                           (* 2 (* 2 5)) (+ (* 2 5) (* 2 5)) (+ (* 2 5) (* 2 5))
                           (* 2 (* 2 5)) (* 2 (* 2 5)))))

(check-equal? (run* (q) (graph-applyo
                         reduces
                         '(+ (exp (log 5)) 5)
                         '(+ 5 5)))
              '(_.0))

(check-equal? (run 5 (q) (graph-applyo reduces q 5))
              '((exp (log 5))
                (exp (log (exp (log 5))))
                (exp (log (exp (log (exp (log 5))))))
                (exp (log (exp (log (exp (log (exp (log 5))))))))
                (exp (exp (log (log 5))))))

(check-equal? (run 5 (q)
                   (fresh (r)
                     (graph-applyo reduces q `(* 2 ,r))))
              '((+ _.0 _.0)
                (exp (log (* 2 _.0)))
                (exp (log (+ _.0 _.0)))
                (exp (log (exp (log (* 2 _.0)))))
                (+ (+ _.0 _.0) (+ _.0 _.0))))
#+END_SRC

** Rewrite Relations

#+NAME: rule-operator
#+BEGIN_SRC scheme :eval never :exports none :results none
(define-syntax rewrite-rules
  (syntax-rules (->)
    ((_ (q ...) (l -> r) ...)
      ;; TODO: Call a function above that produces the critical pairs.
      ;; The output should ultimately be a set of "completed"
      ;; `conde' rewrite rules?
      `((,l ,r) ...))))
#+END_SRC

#+NAME: rule-extractor
#+BEGIN_SRC scheme :eval never :exports none :results none
(define-syntax extract-rewrite-rules
  (syntax-rules ()
    ((_ (conde
         ((== l x) ...))
        ;; TODO: Collect `(== l ...)` and `(== r ...)` pairs in
        ;; branches to form rewrite rules.  Maybe even replace/unique-ify
        ;; the involved logic variables.
     (`((,x ,y) ...)))))
#+END_SRC

* Discussion

:TODO:
- Summarize results
- Describe future work
- etc.
:END:

#+BIBLIOGRAPHY: ../tex/mk-term-rewriting.bib
#+BIBLIOGRAPHYSTYLE: plainnat

# Local Variables:
# geiser-scheme-implementation: racket
# eval: (put 'fresh 'scheme-indent-function 1)
# End:
