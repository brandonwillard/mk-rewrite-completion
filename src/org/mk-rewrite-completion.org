#+TITLE: Knuth-Bendix Completion in miniKanren
#+AUTHOR: Brandon T. Willard
#+DATE: 2019-03-28
#+EMAIL: brandonwillard@gmail.com

#+STARTUP: hideblocks indent hidestars
#+OPTIONS: author:t date:t ^:nil toc:nil title:t tex:t d:(not "logbook" "todo" "notes")
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport

#+PROPERTY: header-args :eval never :exports both :results output drawer replace :noweb yes
#+PROPERTY: header-args+ :session mk-rewrites

#+SETUPFILE: latex-setup.org
# #+INCLUDE: org-setup.el

#+BEGIN_abstract
An investigation into the use of the Knuth-Bendix completion algorithm in
miniKanren.
#+END_abstract

* Introduction

Consider the following subset of group axiom identities--specifically, inverse elements,
identity elements, and associativity:
\begin{equation}
  \begin{aligned}
    1 \cdot x &= x
    \\
    x^{-1} \cdot x &= 1
    \\
    (x \cdot y) \cdot z &= x \cdot (y \cdot z)
  \;.
  \end{aligned}
  \label{eq:group-axioms}
\end{equation}


In miniKanren [[citep:ByrdRelationalProgrammingminiKanren2009]], we can produce
a uni-directional rewrite relation based on [[Cref:eq:group-axioms]] as
follows:
#+NAME: mk-algebra-rewrite-example-defs
#+BEGIN_SRC scheme :eval yes :exports code :results silent :noweb strip-export
<<scheme-setup>>
<<rewrite-functions>>
<<graph-relations>>

(define reduces
  (lambda (a b)
    (conde
     ((fresh (x)
        (== a `(* 1 ,x))
        (== b x)))
     ((fresh (x)
        (== a `(* (i ,x) ,x))
        (== b 1)))
     ((fresh (x y z)
        (== a `(* (* ,x ,y) ,z))
        (== b `(* ,x (* ,y ,z))))))))
#+END_SRC

When accompanied by a relation, src_scheme{graph-applyo}, that traverses forms,
reduction relations will produce every applicable reduction--as shown in
[[mk-algebra-rewrite-example-1]].
If the rewrite rules adhere to a reduction order, then we may be able to
identify some normal forms in the output (e.g. src_scheme{1}).  Otherwise, we
find intermediate reductions in the output of [[mk-algebra-rewrite-example-1]],
which implicitly show the src_scheme{conde} branches that produced successful
goals in src_scheme{reduces}.
#+NAME: mk-algebra-rewrite-example-1
#+BEGIN_SRC scheme :eval yes :exports both :results output code :noweb strip-export
(display (pretty-format
          (run* (q) (graph-applyo reduces '(* (* (i x) x) y) q))
          25
          #:mode 'display))
#+END_SRC

#+RESULTS: mk-algebra-rewrite-example-1
#+begin_src scheme
((* (i x) (* x y))
 (* 1 y)
 y)
#+end_src

In [[mk-algebra-rewrite-example-defs]] we only considered the rewrite rules implied
by left-to-right substitutions in the more general equations of
[[Cref:eq:group-axioms]].  Outside of the miniKanren context and under the
same rewrite rules, we obtain the following normal form for \((x^{-1} \cdot x) \cdot y\)
through repeated application of the same rewrite rules in order (see
[[citep:HarrisonIntroductionlogicautomated2007][Chapter 4.7]] and
[[citep:BaaderTermrewritingall1999][Chapter 1]]):.
#+NAME: group-normalize-order-1-example
#+BEGIN_SRC scheme :eval yes :exports both :results value code :noweb strip-export
<<scheme-setup>>
<<rewrite-functions>>

(let ([rules (rewrite-rules (x y z)
                            ((* (* x y) z) -> (* x (* y z)))
                            ((* 1 x) -> x)
                            ((* (i x) x) -> 1))])
  (normalize '(* (* (i x) x) y) rules))
#+END_SRC

#+RESULTS: group-normalize-order-1-example
#+begin_src scheme
#+end_src

It just so happens that our left-to-right rewrite rule interpretation of [[Cref:eq:group-axioms]]
does reduce terms, and--as a result--can produce normal forms.

Now, consider the normal form for \((x \cdot x^{-1}) \cdot y\); as with our
example above, it should be \(y\).  Our naively derived rewrite
rules will not produce the expected normal form, because the identity \(x \cdot
x^{-1}\) is not present--although it is implied by [[Cref:eq:group-axioms]].

Unfortunately, the addition of new rewrite rules to compensate for this
deficiency can easily remove any reducibility guarantees afforded by our original set
of rules.  For instance, if we add commutativity \(x \cdot y \to y \cdot x\), even
in more restricted forms, we will produce a non-terminating rewrite system.

In a more general context, we need a means of automatically deriving rewrite
rules with normalization and confluence guarantees.  These properties are also required
for type checking relations and other rewrite-driven operations that,
say, determine the validity of statements like "Is \(x \cdot x^{-1} = 1\) also
true/valid under [[Cref:eq:group-axioms]]?".  Knuth-Bendix completion is one such
approach, and it works by producing a set of "complete" rewrite rules for a
given set of equations.

For example, a complete set of rewrite rules for [[Cref:eq:group-axioms]] is given
by the following:
\begin{equation}
  \begin{aligned}
    1 \cdot x &\to x
    \\
    x^{-1} \cdot x &\to 1
    \\
    (x \cdot y) \cdot z &\to x \cdot (y \cdot z)
    \\
    x^{-1} \cdot (x \cdot y) &\to y
    \\
    1^{-1} &\to 1
    \\
    x \cdot 1 &\to x
    \\
    (x^{-1})^{-1} &\to x
    \\
    x \cdot x^{-1} &\to 1
    \\
    x \cdot (x^{-1} \cdot y) &\to y
    \\
    (x \cdot y)^{-1} &\to y^{-1} x^{-1}
  \;.
  \end{aligned}
\label{eq:group-completion}
\end{equation}

The rewrite rules in [[Cref:eq:group-completion]] can be produced mechanically from
[[Cref:eq:group-axioms]]--and a generic reduction order--using Knuth-Bendix
completion (e.g. Huet's procedure).  As we can see, the commutative inverse
identity (i.e. \(x^{-1} \cdot x = x \cdot x^{-1}\)) is present in a form that
preserves termination, along with other important rewrites that we might have
easily missed when attempting to manually produce a complete set of rules.


miniKanren implements a complete search [[citep:HemannSimpleCompleteSearch2018,
Hemannsmallembeddinglogic2016]], which alongside lazily evaluated results, can
be used to obtain all possible reductions under the fully enumerated set of
possible replacement rules implied by a set of equations.  However, this
approach produces infinite goal streams and only moves the standard
term-rewriting normal-form and termination concerns to the callers of said
relations.

Additionally, there are performance issues that result from the inherently large
search spaces induced by such relations.  Every matching src_scheme{conde}
clause that does not produce a normal form is essentially a wasted step.  The completions
produced by Knuth-Bendix procedures can guarantee--via (local) coherence--that
every successful unification ultimately leads to a normal form.
Likewise, some refinements [[citep:Metivierrewritingsystemsproduced1983]] of
these completion procedures are able to reduce the number of reduction rules and
quite possibly the number of redundant src_scheme{conde} clauses/unifications.


Toward the same ends, some of these issues can be mitigated through alterations
to the search process [[citep:SwordsGuidedSearchminiKanren, ZhangNeuralGuidedConstraint2018, BoskinSurprisinglyCompetitiveConditional2018]].
These approaches tend to introduce more opportunities to unknowingly violate the
relational paradigm upon which miniKanren capitalizes, but--more
importantly--they can require a distinct effort from the developer to provide
context-dependent logic that actually *does* improve the search.
In some circumstances, that logic will necessarily overlap with the aims of
term-rewriting completion described here.

For an important set of situations, we can use standard term rewriting
automations that do not involving alterations to the underlying mechanics of
miniKanren's search--or its fundamental relations/goals--and are able to provide
improvements to the specification and application of relational identities that
produce term rewriting systems.

** Notation and Implementations

In what follows, we will use \(\mathcal{R}\) to represent a set of rewrite rules
and \(\mathcal{T}\left(\mathcal{F}, \mathcal{V}\right)\) as a set of terms
derived from a set of function symbols \(\mathcal{F}\) and variables
\(\mathcal{V}\).  These are combined to form a term rewriting system
\(\left(\mathcal{R}, \mathcal{R}\right)\).

Throughout, we will use Racket to implement the term rewriting mechanics and
miniKanren implementations.

#+NAME: kanren-requires
#+BEGIN_SRC scheme :eval yes :exports code :results silent :noweb-ref scheme-setup
(require rackunit)
(require racket/pretty)
(require minikanren)

;; For interactive debugging, try `raco pkg install debug` and the following:
;; (require debug/repl)
;; Then use `(debug-repl)` and `(resume)'.

;; Similarly...
(require errortrace)

;; Include un-`provided` core functions.
(require/expose minikanren/minikanren (unify var var? reify walk*))
#+END_SRC

:TODO:
We could/should have structs for terms, rewrite rules, etc.
This approach uses [[https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._make-reader-graph%29%29][reader graphs]], which allow us to make src_scheme{equals?}
ignore src_scheme{var} and swap out/ground variables effortlessly.

#+RESULTS: term-structs
#+BEGIN_SRC scheme :eval never :exports none :results none
;; (require racket/base)
;; (require (except-in racket cons list)
;;          (rename-in racket [cons base-cons] [list base-list]))
(require racket/generic)
(require data/order)

(define-generics term
  (ground? term)
  ;; TODO: overloading `cons' would allow us to assemble `term' objects
  ;; incrementally (e.g. union their sets of placeholders in `term-vars').
  ;; Seems like there's something I'm not understanding about this generics
  ;; interface/macro, though...
  #:defaults  ([list?
                (define (ground? term)
                  (set-empty? (vars term)))]))

(check-false (ground? `(i ,(var 0))))
(check-true (ground? `(i e)))

(struct term-graph (graph vars)
        #:transparent
        #:constructor-name make-term-graph
        #:omit-define-syntaxes
        #:guard
        (lambda (graph vars type-name)
          (cond
           [(term-graph? graph)
            (values (term-graph-graph graph) (term-graph-vars graph))]
           [else (values graph vars)]))
        #:methods gen:term
        [(define (ground? self)
           (set-empty? (term-graph-vars self)))]
        #:methods gen:equal+hash
        [(define (equal-proc a b equal?-recur)
           ;; We don't want vars to throw off the comparison, so we use the
           ;; reader graphs and their placeholders.
           (equal?-recur (term-graph-graph a) (term-graph-graph b)))
         (define (hash-proc a hash-recur)
           (hash-recur (term-graph-graph a)))
         (define (hash2-proc a hash2-recur)
           (hash2-recur (term-graph-graph a)))])

(define (term-graph form)
  (cond
   [(term-graph? form)
    (make-term-graph (term-graph-graph form) (term-graph-vars form))]
   [else
    (let* ([form-vars (vars form)]
           [ph-alist (for/list ([v form-vars]
                                [i (range (set-count form-vars))])
                       (cons v (make-placeholder
                                (string->symbol (format "*x~a*" i)))))]
           [graph (replace-in-graph ph-alist form)])
      (make-term-graph (make-reader-graph graph)
                       (for/set ([v ph-alist]) (cdr v))))]))

(let ([t1 (term-graph `(i ,(var 0)))]
      [t1-2 (term-graph `(i ,(var 1)))]
      [t2 (term-graph `(i e))])
  (printf "~a" t1)
  (check-true (equal? t1 t1-2))
  (check-false (equal? t1 t2))
  (check-false (ground? t1))
  (check-true (ground? t2)))

(struct rewrite-rule (lhs rhs)
        #:transparent
        #:guard
        (lambda (lhs rhs type-name)
          (cond
           [(not (and (term-graph? lhs) (term-graph? rhs)))
            (error type-name "Both arguments must be term graphs.")]
           [else (values lhs rhs)]))
        #:methods gen:custom-write
        [(define (write-proc rule port mode)
           (fprintf port "~a -> ~a"
                    (rewrite-rule-lhs rule)
                    (rewrite-rule-rhs rule)))])

(struct equation (lhs rhs)
        #:transparent
        #:guard
        (lambda (lhs rhs type-name)
          (cond
           [(not (and (term-graph? lhs) (term-graph? rhs)))
            (error type-name "Both arguments must be term graphs.")]
           [else (values lhs rhs)]))
        #:methods gen:equal+hash
        [(define (equal-proc a b equal?-recur)
           ;; TODO: Equality of equations should not be affected by lhs, rhs order.
           (or (equal?-recur
                (term-graph-graph (equation-lhs a))
                (term-graph-graph (equation-lhs b)))
               (equal?-recur
                (term-graph-graph a)
                (term-graph-graph b))))
         (define (hash-proc a hash-recur)
           ;; TODO: Seems like we would need an ordering for this, no?
           (hash-recur (term-graph-graph a)))
         (define (hash2-proc a hash2-recur)
           (hash2-recur (term-graph-graph a)))]
        #:methods gen:custom-write
        [(define (write-proc eqn port mode)
           (fprintf port "~a = ~a"
                    (equation-lhs eqn)
                    (equation-rhs eqn)))])

(let ([t (term-graph `(1 ,(var 0)))])
  t)

(let ([rule (rewrite-rule (term-graph `(1 ,(var 0))) (term-graph 1))])
  rule)
#+END_SRC
:END:

The macros in [[rewrite-macros]] make it easier to specify a set of rewrite
rules through the following syntax:
#+NAME: rewrite-macro-usage
#+BEGIN_SRC scheme :eval never :exports code :results none
(rewrite-rules (x y)
               ((f (g x x) y) -> (g x y))
               ((g x y) -> x))
#+END_SRC

Listing [[rewrite-macro-usage]] expands to the following:
#+NAME: rewrite-macro-expanded
#+BEGIN_SRC scheme :eval never :exports code :results none
'(list
  (let ((xv `((x unquote (var (gensym)))
              (y unquote (var (gensym))))))
    (replace-in-graph xv '((f (g x x) y) g x y)))
  (let ((xv `((x unquote (var (gensym)))
              (y unquote (var (gensym))))))
    (replace-in-graph xv '((g x y) . x))))
#+END_SRC

#+ATTR_LATEX: :float t :placement h!
#+CAPTION:
#+NAME: rewrite-macros
#+BEGIN_SRC scheme :eval yes :exports code :results none :noweb-ref rewrite-functions
;; Returns all the variables in a term graph.
(define (vars x [res (set)])
  (match x
   [(cons a b)
    (let* ([res (vars a res)])
      (vars b res))]
   [(? var? x)
    (if (set? res)
        (set-add res x)
        (if (member x res)
            res
            (append res (list x))))]
   [_ res]))

;; Replace elements in a term graph according to an alist.
(define (replace-in-graph xv graph)
  (match graph
    [(cons h t)
     (cons (replace-in-graph xv h) (replace-in-graph xv t))]
    [_
     (let* ([r-pair (assoc graph xv)])
       (if r-pair
           (cdr r-pair)
           graph))]))

(define-syntax (rewrite-rules stx)
  (syntax-case stx (->)
    [(_ (x ...) (l -> r) ...)
     #`(list
        (let ([xv `((x . ,(var (gensym))) ...)])
          (replace-in-graph xv (quote (l . r)))) ...)]))
#+END_SRC

#+NAME: rewrite-macros-tests
#+BEGIN_SRC scheme :eval yes :exports none :results silent
(match-let ([(list v0 v1 v2 v3 v4)
             (for/list ([v (range 5)]) (var v))])
  (check-equal?
   (vars `(f (g ,v0 x (,v0 ,v2 ,v3)) ,v1 (h (j (k ,v4) ,v3))))
   (set v1 v3 v0 v4 v2)))

(check-true (let ([q (car (rewrite-rules (x y) (x -> x)))])
              (eq? (car q) (cdr q))))
#+END_SRC

The functions in Listing [[rewrite-helper-functions]] apply rewrite rules to a form.
Specifically, the function src_scheme{normalize} attempts to produce a
fixed-point/normalized result through repeated application of the rewrite rules.

#+ATTR_LATEX: :float t :placement h!
#+CAPTION:
#+NAME: rewrite-helper-functions
#+BEGIN_SRC scheme :eval yes :exports code :results none :noweb-ref rewrite-functions
;; Convert vars in a graph according to a function taking a number assigned to
;; each var observed (in order).
(define (vars-to-symbols x [fn (lambda (i) (string->symbol (format "x~a" i)))])
  (let* ([x-vars (vars x '())]
         [new-vars (for/list ([v x-vars]
                              [i (range (set-count x-vars))])
                     (cons v (fn i)))]
         [x-new (replace-in-graph new-vars x)])
    x-new))

(define (print-pair delim rules)
  (cond
   [(list? rules)
    (for ([rule rules])
      (match rule
        [(cons r l)
         (printf "\t~a ~a ~a\n" r delim l)]))]
   [else
    (match rules
      [(cons r l)
       (printf "\t~a ~a ~a\n" r delim l)])]))

(define print-rule (curry print-pair "->"))
(define print-eqn (curry print-pair "="))

;; Apply a function on a grounded version of a term graph; afterward,
;; any resulting grounded terms are replaced with their original variables.
(define (apply-on-grounded fn t [lst '()])
  (let* ([t-vars (vars t)]
         [var-alist (for/list ([v t-vars])
                      (cons v (gensym)))]
         ;; Ground the vars in term `t'.
         [t-gnd (replace-in-graph var-alist t)]
         [t-new (apply fn t-gnd lst)]
         [rev-alist (for/list ([v var-alist])
                      (cons (cdr v) (car v)))])
    ;; Un-ground the grounded vars.
    (replace-in-graph rev-alist t-new)))

;; Apply a single rewrite rule or `#f`.
(define (rewrite-1 t lr)
  (if (var? t)
      t
      (match lr
        [(cons l r)
         (let* ([θ (unify l t '())]
                [t-new (if (eq? θ #f)
                           #f
                           (begin
                             ;; (printf "------\nθ = ~a\n" θ)
                             ;; (printf "rewrite-1: [~a -> ~a]  ~a -> ~a\n" l r t (walk* r θ))
                             (walk* r θ)))])
           t-new)])))

;; Apply the first rewrite rule that unifies; return `#f` otherwise.
(define (-rewrite rules t)
  (ormap (curry rewrite-1 t) rules))

;; Apply rewrite rules until a fixed-point is reached.
(define (-normalize rules t)
  (match t
    [(cons t-car t-cdr)
     (let ([t-cdr-new (for/list ([a (if (list? t-cdr)
                                        t-cdr
                                        (list t-cdr))])
                        (-normalize rules a))])
       (if (eq? t-cdr-new #f)
           t
           (begin
             ;; (printf "normalize: ~a -> ~a\n" t-cdr t-cdr-new)
             (let* ([t-new (cons t-car t-cdr-new)]
                    [t-new-new (-rewrite rules t-new)])
               (if (or (eq? t-new-new #f) (equal? t-new-new t-new))
                   t-new
                   (begin
                     ;; (printf "normalize: ~a -> ~a\n" t-new t-new-new)
                     (-normalize rules t-new-new)))))))]
    [_ t]))

(define (normalize rules t)
  (apply-on-grounded (curry -normalize rules) t))

(define (rewrite rules t)
  (let ([res (apply-on-grounded (curry -rewrite rules) t)])
    (if (eq? res #f)
        t
        res)))
#+END_SRC

#+NAME: rewrite-helper-functions-tests
#+BEGIN_SRC scheme :eval yes :exports none :results silent
(check-equal? (rewrite (let ([q (var 0)]
                             [w (var 1)])
                         `(((g ,q ,w) . ,w)
                           ((i) . 1)))
                       '(f x y))
              '(f x y))
(check-equal? (rewrite (let ([q (var 0)]
                             [w (var 1)])
                         `(((g ,q ,w) . ,w)
                           ((i) . 1)))
                       '(g x (i)))
              '(i))

(check-equal? (normalize (let ([q (var 0)]
                               [w (var 1)]
                               [z (var 2)])
                           `(((g ,q ,w) . ,w)
                             ((f ,z) . ,z)
                             ((i) . 1)))
                         '(g (f i) (i)))
              1)
(check-equal? (normalize (let ([q (var 0)]
                               [w (var 1)]
                               [z (var 2)])
                           `(((g ,q ,w) . (+ ,q ,w))
                             ((f ,z) . ,z)
                             ((i) . 1)))
                         '(g (f (i)) (i)))
              '(+ 1 1))
(check-equal? (normalize (rewrite-rules (q w z)
                           ((+ 1 1) -> (+ 1 1))
                           ((g q w) -> (+ q w))
                           ((f z) -> z)
                           ((i) -> 1))
                         '(g (f (i)) (i)))
              '(+ 1 1))
#+END_SRC

* Rewrite Rule Completion
** Critical Pairs
Following [[citet:BaaderTermrewritingall1999]] Definition 6.2.1,
#+ATTR_LATEX: :options [Critical Pairs]
#+BEGIN_definition
For \(l_i \to r_i\), \(i \in \left\{1, 2\right\}\) with
\(\bigcap_{i \in \left\{1, 2\right\}} \operatorname{Vars}\left(l_i, r_i\right) = \emptyset\),
let \(p \in \operatorname{Pos}\left(l_1\right)\) and \(\theta\) a most general
unifier of \(l_1 \mid_{p} =^{?} l_2\) s.t. \(l_1 \mid_{p}\) is not a variable, then
\(l_i \to r_i\) determine a *critical pair*
\({\langle \theta r_1, \left(\theta l_1\right)\left[\theta r_2\right]_p \rangle}\).
#+END_definition

The functions in Listing [[critical-pairs-functions]] compute the critical pairs between
two rewrite rules.
#+NAME: critical-pairs-functions
#+BEGIN_SRC scheme :eval yes :exports code :results none :noweb-ref cp-functions :noweb strip-export
<<scheme-setup>>
<<rewrite-functions>>

(define (match-and-replace term rules matches)
  (cond
   [(not (var? term))
    (append
     matches
     (append-map
      (lambda (rule)
        (match-let* ([(cons l2 r2) rule])
          (let* ([θ (unify term l2 '())])
            (if (eq? θ #f)
                matches
                (list (cons θ r2))))))
      rules))]
   [else
    matches]))

(define (walk-matches graph rules matches [match-graph #t])
  (let* ([new-matches
          ;; Check the whole term/graph.
          (if match-graph
              (match-and-replace graph rules '())
              '())])
    ;; Descend into the term/graph.
    (match graph
      [(cons rator rands)
       (let* ([rator-matches (walk-matches rator rules '())]
              [rands-matches (walk-matches rands rules '() #f)])
         (append
          matches
          new-matches
          (for/list ([m rator-matches])
            (match-let* ([(cons θ new-rator) m]
                         [new-graph (cons new-rator rands)])
              (when (and (cons? new-graph) (not (list? new-graph)))
                  (error "rator bad cons:" rator new-rator rules))
              (cons θ new-graph)))
          (for/list ([m rands-matches])
            (match-let* ([(cons θ new-rands) m]
                         [new-graph (cons rator new-rands)])
              (when (and (cons? new-graph) (not (list? new-graph)))
                  (error "rands bad cons:" rands new-rands rules))
              (cons θ new-graph)))))]
      [else (append matches new-matches)])))

(define (critical-pairs rule1 rule2)
  (match-let* (;; Make sure that variables in rules don't overlap.
               [rule-new (vars-to-symbols rule1 (lambda (i) (var (gensym))))]
               [(cons l1 r1) rule-new]
               [match-res (walk-matches l1 rule2 '())])
    (for/list ([m match-res])
      (match-let* ([(cons θ lrp) m]
                   [cp-car (walk* r1 θ)]
                   [cp-cdr (walk* lrp θ)])
        (cons cp-car cp-cdr)))))
#+END_SRC

The function in Listing [[all-critical-pairs]] computes all critical pairs between a
set of rewrite rules.
#+NAME: all-critical-pairs
#+BEGIN_SRC scheme :eval yes :exports code :results none :noweb-ref cp-functions
(define (all-critical-pairs rules)
  (append-map
   (lambda (rule)
     (critical-pairs rule rules))
   rules))
#+END_SRC

#+RESULTS: critical-pairs-tests
#+BEGIN_SRC scheme :eval yes :exports none :results silent :noweb yes
;; Expected "raw" critical pairs:
;; 1 (+ x1 x0) -> (+ x1 x0)
;; 2 (+ (s x1) x0) -> (s (+ x0 x1))
;; 2 (+ (s x1) x0) -> (s (+ x0 x1))
;; 3 (+ x1 (s x0)) -> (s (+ x0 x1))
;; 3 (+ x1 (s x0)) -> (s (+ x0 x1))
;; 4 (s (+ x0 x1)) -> (+ (s x1) x0)
;; 4 (s (+ x0 x1)) -> (+ (s x1) x0)
;; 5 (s (+ x0 x1)) -> (s (+ x0 x1))
;; 6 (s (+ (s x0) x1)) -> (s (+ x0 (s x1)))
;; 6 (s (+ (s x0) x1)) -> (s (+ x0 (s x1)))
;; 7 (s (+ x0 x1)) -> (+ x1 (s x0))
;; 7 (s (+ x0 x1)) -> (+ x1 (s x0))
;; 8 (s (+ x0 (s x1))) -> (s (+ (s x0) x1))
;; 8 (s (+ x0 (s x1))) -> (s (+ (s x0) x1))
;; ---------
;; 1 (+ x0 x1) -> (+ x0 x1)
;; 2 (+ (s x0) x1) -> (s (+ x1 x0))
;; 3 (+ x0 (s x1)) -> (s (+ x1 x0))
;; 4 (s (+ x0 x1)) -> (+ (s x1) x0)
;; 5 (s (+ x0 x1)) -> (s (+ x0 x1))
;; 5 (s (+ x0 x1)) -> (s (+ x0 x1))
;; 6 (s (+ (s x0) x1)) -> (s (+ x0 (s x1)))
;; 7 (s (+ x1 x0)) -> (+ x0 (s x1))
;; 8 (s (+ x1 (s x0))) -> (s (+ (s x1) x0))
(let* ([expected
        '(((+ x0 x1) . (+ x0 x1))
          ((+ (s x0) x1) . (s (+ x1 x0)))
          ((+ x0 (s x1)) . (s (+ x1 x0)))
          ((s (+ x0 x1)) . (+ (s x1) x0))
          ((s (+ x0 x1)) . (s (+ x0 x1)))
          ((s (+ (s x0) x1)) . (s (+ x0 (s x1))))
          ((s (+ x0 x1)) . (+ x1 (s x0)))
          ((s (+ x0 (s x1))) . (s (+ (s x0) x1))))]
       [rules (rewrite-rules (x0 x1)
                ((+ (s x0) x1) -> (s (+ x0 x1)))
                ((+ x0 (s x1)) -> (s (+ x0 x1)))
                ((+ x0 x1) -> (+ x1 x0)))]
       [c-pairs (all-critical-pairs rules)]
       [c-pairs (remove-duplicates
                 (for/list ([cp c-pairs])
                   (vars-to-symbols cp (lambda (i) (var i)))))])
  (check-equal? (list->set (vars-to-symbols c-pairs))
                (list->set expected)))

;; These are the critical pairs and their respective inputs:
;; [((* e x0) . x0), ((* e x0) . x0)]:	[x0, x0]
;; [((* (* x0 x1) x2) * x0 (* x1 x2)), ((* e x0) . x0)]:	[(* e (* x0 x1)), (* x0 x1)]
;; [((* (* x0 x1) x2) * x0 (* x1 x2)), ((* (* x0 x1) x2) * x0 (* x1 x2))]:	[(* (* x0 x1) (* x2 x3)), (* (* x0 (* x1 x2)) x3)]
;; [((* (* x0 x1) x2) * x0 (* x1 x2)), ((* (* x0 x1) x2) * x0 (* x1 x2))]:	[(* x0 (* x1 x2)), (* x0 (* x1 x2))]
;; [((* (* x0 x1) x2) * x0 (* x1 x2)), ((* (i x0) x0) . e)]:	[(* (i x0) (* x0 x1)), (* e x0)]
;; [((* (i x0) x0) . e), ((* (i x0) x0) . e)]:	[e, e]
;; (let ([x0 (var 0)]
;;       [x1 (var 1)])
;;   (critical-pairs '((* e x0) . x0) '((* e x0) . x0)))
;; Generated from:
;; (let* ([eqns (rewrite-rules (x y z)
;;                ((* e x) -> x)
;;                ((* (* x y) z) -> (* x (* y z)))
;;                ((* (i x) x) -> e))]
;;        [pairs (cartesian-product eqns eqns)])
;;   (for ([p pairs])
;;     (match-let* ([(list r1 r2) p])
;;       (for ([cps (critical-pairs r1 r2)])
;;         (match cps
;;           [(cons cp1 cp2)
;;            (printf "[~a, ~a]:\t[~a, ~a]\n"
;;                    (vars-to-symbols r1)
;;                    (vars-to-symbols r2)
;;                    (vars-to-symbols cp1)
;;                    (vars-to-symbols cp2))]
;;           [_ (printf "none\n")])))))

(let* ([eqns (rewrite-rules (x y z)
               ((* e x) -> x)
               ((* (* x y) z) -> (* x (* y z)))
               ((* (i x) x) -> e))]
       [expected
        '((x0 . x0)
          ;; TODO: Why does the OCaml code swap these orders?
          ;; ((* x0 x1) . (* e (* x0 x1)))
          ((* e (* x0 x1)) . (* x0 x1))
          ;; ((* e x0) . (* (i x1) (* x1 x0)))
          ((* (i x0) (* x0 x1)) . (* e x1))
          ((* x0 (* x1 x2)) . (* x0 (* x1 x2)))
          ;; ((* (* x0 (* x1 x2)) x3) . (* (* x0 x1) (* x2 x3)))
          ((* (* x0 x1) (* x2 x3)) . (* (* x0 (* x1 x2)) x3))
          (e . e))]
       [c-pairs (all-critical-pairs eqns)]
       [c-pairs (remove-duplicates
                 (for/list ([cp c-pairs])
                   (vars-to-symbols cp (lambda (i) (var i)))))])
  ;; (print-rule expected)
  ;; (printf "---------\n")
  ;; (print-rule (vars-to-symbols c-pairs))
  (check-equal? (list->set (vars-to-symbols c-pairs))
                (list->set expected)))

(let* ([eqns (rewrite-rules (x y z)
               ((* (i x) (* x y)) -> y))]
       [expected '(((* x0 x1) . (* (i (i x0)) x1))
                   (x0 . x0))]
       [c-pairs (all-critical-pairs eqns)]
       [c-pairs (remove-duplicates
                 (for/list ([cp c-pairs])
                   (vars-to-symbols cp (lambda (i) (var i)))))])
  ;; (print-eqn (vars-to-symbols c-pairs))
  (check-equal? (list->set (vars-to-symbols c-pairs))
                (list->set expected)))
#+END_SRC

A simple example from [[citet:BaaderTermrewritingall1999][Example 6.2.2]] is given in
Listing [[all-critical-pairs-example]]:

#+NAME: all-critical-pairs-example
#+BEGIN_SRC scheme :eval yes :exports both :results output code
(let ([cpairs (all-critical-pairs
        (rewrite-rules (x y z)
          ((f (f x y) z) -> (f x (f y z)))
          ((f (i x) x)  -> e)))])
  (print-rule cpairs))
#+END_SRC

#+RESULTS: all-critical-pairs-example
#+begin_src scheme
	(f #(g884) (f #(g885) #(g886))) -> (f #(g884) (f #(g885) #(g886)))
	(f (f #(g884) #(g885)) (f #(g886) #(g892))) -> (f (f #(g884) (f #(g885) #(g886))) #(g892))
	(f (i #(g887)) (f #(g887) #(g892))) -> (f e #(g892))
	e -> e
#+end_src

** Orderings

To start, we consider a basic cardinality-based measure on term-graphs
[[citep:HarrisonIntroductionlogicautomated2007][Chapter 4.6]].

#+ATTR_LATEX: :options [Term-graph cardinality measure]
#+NAME: term-graph-measure-based-order
#+BEGIN_definition
The order \(s > t\) is given by \(\abs{s} > \abs{t}\) for terms \(s, t \in
\mathcal{T}\) and cardinality measure \(\abs{s}\).
#+END_definition

#+NAME: term-size-function
#+BEGIN_SRC scheme :eval yes :exports code :results none :noweb-ref order-functions
(define graph-size
  (lambda (t)
    (if (var? t)
        1
        (foldl (lambda (x n)
                 (+ n (graph-size x)))
               1 (cdr t)))))
#+END_SRC

#+NAME: term-size-tests
#+BEGIN_SRC scheme :eval yes :exports none :results silent
(let ([x (var 0)]
      [y (var 1)]
      [z (var 2)])
  (check-eq? (graph-size x) 1)
  (check-eq? (graph-size `(f ,x)) 2)
  (check-eq? (graph-size `(f ,x ,y)) 3)
  (check-eq? (graph-size `(f (g ,x))) 3)
  (check-eq? (graph-size `(f (f ,x ,y) ,z)) 5))
#+END_SRC

#+NAME: term-size-order
#+BEGIN_SRC scheme :eval yes :exports none :results none :noweb-ref order-functions
(define size-gt
  (lambda (t1 t2)
    (> (graph-size t1) (graph-size t2))))
#+END_SRC

We need a *reduction order* for Knuth-Bendix completion.  The standard
cardinality measure itself will not suffice, since it is not closed under
substitutions [[citep:BaaderTermrewritingall1999][Example 5.2.2]].

An extension to the cardinality order is the strict reduction order given by
\(s > t \iff \abs{s} > \abs{t}\), \(s, t \in \mathcal{T}\) such that \(\forall x \in \mathcal{V}\),
\(\abs{s}_x \geq \abs{t}_x\), where \(\abs{t}_x\) is the number of occurrences
of \(x\) in \(t\).  However, according to
[[citet:HarrisonIntroductionlogicautomated2007]], this reduction order is not
well-suited for algebraic theories.

*** Lexicographical Path Order
Instead, we will use the standard lexicographical path order (LPO)
[[citep:BaaderTermrewritingall1999][Example 5.4.12]].

The LPO order will need an operator-symbol measure.  In other words, an
order--possibly arbitrary--is imposed on function symbols like \(*\), \(f\),
etc., considered together with their effective arities.

Our implementations roughly follow
[[citet:HarrisonIntroductionlogicautomated2007][Chapter 4.6]].

#+NAME: op-gt
#+BEGIN_SRC scheme :eval yes :exports code :results none :noweb-ref order-functions
;; Greater-than comparison of operator symbols against a given
;; ordering (implied by an ordered list containing all known operators)
;; and their arities--when applicable.
(define (op-gt op-list t1 t2)
  (cond
   [(and (symbol? t1) (symbol? t2))
    (> (length (or (member t1 op-list)
                   (error 'op-gt "op ~a not found." t1)))
       (length (or (member t2 op-list)
                   (error 'op-gt "op ~a not found." t2))))]
   [(and (list? t1) (list? t2))
    (match-let ([(cons t1-rator t1-rands) t1]
                [(cons t2-rator t2-rands) t2])
      (if (eq? t1-rator t2-rator)
          (> (length t1-rands) (length t2-rands))
          (> (length (or (member t1-rator op-list)
                         (error 'op-gt "op ~a not found." t1-rator)))
             (length (or (member t2-rator op-list)
                         (error 'op-gt "op ~a not found." t2-rator))))))]))
#+END_SRC

#+NAME: op-gt-tests
#+BEGIN_SRC scheme :eval yes :exports none :results silent
(check-true (op-gt '(+ e) '(+ 1) '(e)))
(check-true (op-gt '(e +) '(e) '(+ 1)))
(check-false (op-gt '(e +) '(+ 1) '(e)))
(check-true (op-gt '(e +) '(+ 1 2 3) '(+ 1 2)))
(check-false (op-gt '(e +) '(+ 1 2) '(+ 1 2 3)))
(check-true (op-gt '(e +) 'e '+))
(check-false (op-gt '(e +) '+ 'e))
(check-false (op-gt '(e +) '+ '+))
#+END_SRC

#+NAME: lex-order
#+BEGIN_SRC scheme :eval yes :exports code :results none :noweb-ref order-functions
;; Lexicographical extension of an order.
(define (lex-gt order t1 t2)
  (match* (t1 t2)
    [((cons t1-car t1-cdr) (cons t2-car t2-cdr))
     (if (order t1-car t2-car)
         (eq? (length t1-cdr) (length t2-cdr))
         (and (eq? t1-car t2-car)
              (lex-gt order t1-cdr t2-cdr)))]
    [(_ _) #f]))
#+END_SRC

#+NAME: lex-order-tests
#+BEGIN_SRC scheme :eval yes :exports none :results silent
(check-true (lex-gt eq? '(f) '(f)))
(check-true (lex-gt eq? '(f g) '(f g)))
(check-false (lex-gt eq? '(f g) '(f)))
(check-false (lex-gt eq? '(f) '(f g)))
#+END_SRC

#+NAME: lpo-orders
#+BEGIN_SRC scheme :eval yes :exports code :results none :noweb-ref order-functions
;; Lexicographical path order.
(define (lpo-gt op-ord t1 t2)
  ;; Constants are expressed as 0-arity functions--for consistency,
  ;; so we transform symbols that represent them into S-expressions.
  (let ([t1 (if (symbol? t1) (list t1) t1)]
        [t2 (if (symbol? t2) (list t2) t2)])
    (match* (t1 t2)
            [(_ (? var? t2))
               (and (not (eq? t1 t2))
                    ;; FIXME: Seems pretty wasteful.  Some state would be good here?
                    (set-member? (vars t1) t2))]
            [((cons t1-rator t1-rands) (cons t2-rator t2-rands))
             (or (ormap (lambda (x)
                          (or (eq? x t2)
                              (lpo-gt op-ord x t2)))
                        t1-rands)
                 (and (andmap (curry lpo-gt op-ord t1) t2-rands)
                      (or (op-ord t1-rator t2-rator)
                          (and (eq? t1-rator t2-rator)
                               (lex-gt (curry lpo-gt op-ord) t1-rands t2-rands)))))]
            [(_ _) #f])))

;; LPO's completion.
(define (lpo-ge op-ord t1 t2)
  (or (eq? t1 t2)
      (lpo-gt op-ord t1 t2)))
#+END_SRC

#+NAME: lpo-orders-tests
#+BEGIN_SRC scheme :eval yes :exports code :results silent
(check-false (lpo-gt (curry op-gt '(f g)) `(f) `(f)))
(check-true (lpo-gt (curry op-gt '(f g)) `(f) `(g)))
(check-false (lpo-gt (curry op-gt '(f g)) `(g) `(f)))
(check-false (lpo-gt (curry op-gt '(f g x)) `(f ,(var 0)) `(f x)))

(let ([x (var 0)]
      [y (var 1)]
      [z (var 2)]
      [op-gt (curry op-gt '(i f e))])
  ;; Tests from Example 5.4.13
  (check-true (lpo-gt op-gt `(i e) 'e))
  (check-true (lpo-gt op-gt `(f ,x e) x))
  (check-true (lpo-gt op-gt `(i (f ,x ,y)) `(f (i ,y) (i ,x))))
  (check-true (lpo-gt op-gt `(i (f ,x ,y)) `(i ,y)))
  (check-true (lpo-gt op-gt `(i (f ,x ,y)) `(i ,x)))
  (check-true (lpo-gt op-gt `(f (f ,x ,y) ,z) `(f ,x (f ,y ,z)))))
#+END_SRC

:TODO:
We could also implement Knuth-Bendix orderings (i.e. using weight functions).
:END:

** Completion
*** The Basic Completion Procedure

#+NAME: normalize-and-orient
#+BEGIN_SRC scheme :eval yes :exports code :results none :noweb-ref completion-functions
;; Normalize a pair (e.g. representing a relation) according to a set of
;; replacement rules and return the car and cdr in the given term ordering.
(define (normalize-oriented ord rules eq)
  (match eq
    [(cons s t)
     (let* ([-s (normalize rules s)]
            [-t (normalize rules t)]
            [s-gt-t (ord -s -t)])
       (cond
        [(boolean? s-gt-t)
         (if s-gt-t
             (cons -s -t)
             (cons -t -s))]
        [else #f]))]))
#+END_SRC

#+NAME: normalize-and-orient-tests
#+BEGIN_SRC scheme :eval yes :exports none :results silent
(let* ([ord (curry lpo-gt (curry op-gt '(* i e)))]
       [rules (rewrite-rules (x y z)
                ((* e x) -> x)
                ((* (* x y) z) -> (* x (* y z)))
                ((* (i x) x) -> e))]
       [x (var (gensym))]
       [eq-1 `(e . (* (* e ,x) (i (* e ,x))))]
       ;; We start with the standard group l -> r rules and
       ;; normalize + orient the following rule: (1 * x) -> (1 * x) * (1 * x)^{-1}.
       ;; First, this equation should reduce to the missing right inverse identity.
       ;; Second, the reduction order should be reversed (i.e. larger term to smaller term).
       [expected-1 `((* ,x (i ,x)) . e)])
  (check-equal? (normalize-oriented ord rules eq-1) expected-1))
#+END_SRC

#+NAME: basic-completion
#+BEGIN_SRC scheme :eval yes :exports code :results none :noweb-ref completion-functions
;; The basic completion algorithm with deferring for nonn-orientable equations
;; from [[citet:HarrisonIntroductionlogicautomated2007][Chapter 4.7]].
(define (-basic-completion ord eqs deferred cpairs max-iter iter)
  (if (> iter max-iter)
      (begin
        (printf "reached max iters\n")
        eqs)
      (match cpairs
        [(cons cp cpairs-cdr)
         (begin
           (printf "------completion-cons (~a)\ncp: " iter)
           (print-eqn (list cp))
           (printf "deferred: \n")
           (print-rule deferred)
           (printf "cpairs-cdr: \n")
           (if (< (length cpairs-cdr) 20)
               (print-eqn cpairs-cdr)
               (printf "~a\n" (length cpairs-cdr)))
           (printf "eqs: \n")
           (if (< (length eqs) 20)
               (print-eqn eqs)
               (printf "~a\n" (length eqs)))
           (let* ([cp-normed (normalize-oriented ord eqs cp)]
                  [arg-list
                   (begin
                     (printf "cp-normed: \n")
                     (if (eq? cp-normed #f)
                         (begin
                           (printf "false\n")
                           ;; If orientation fails, defer the equation.
                           (list eqs (cons cp deferred) cpairs-cdr
                                 max-iter (+ 1 iter)))
                         (match-let* ([(cons -s -t) cp-normed])
                           (print-eqn (list cp-normed))
                           (if (equal? -s -t)
                               (begin
                                 ;; This normalized & oriented critical pair reduces to
                                 ;; the same two terms (i.e. they're joinable), so we
                                 ;; discard it.
                                 (printf "CP (i.e. cp-normed) joins\n")
                                 (list eqs deferred cpairs-cdr
                                       max-iter (+ 1 iter)))
                               ;; Since the normalized & oriented critical pair didn't join, we
                               ;; add it to our list of rewrite rules and compute the
                               ;; critical pairs resulting from it and all the other rules.
                               (let* ([new-eqs (cons cp-normed eqs)]
                                      [new-cpairs (append-map
                                                   (lambda (x)
                                                     (append
                                                      (critical-pairs cp-normed (list x))
                                                      ;; Include transposed pair
                                                      (if (not (equal? cp-normed x))
                                                          (critical-pairs x (list cp-normed))
                                                          '())))
                                                   new-eqs)])
                                 (printf "new-cpairs: \n")
                                 (if (< (length new-cpairs) 20)
                                     (print-eqn new-cpairs)
                                     (printf "~a\n" (length new-cpairs)))
                                 (list new-eqs deferred (set-union new-cpairs cpairs-cdr)
                                       max-iter (+ 1 iter)))))))])
             (apply -basic-completion ord arg-list)))]
        [_
         (if (eq? deferred '())
             ;; No more deferred equations, so we're done.
             eqs
             (begin
               (printf "------completion-non-cons (~a)\neqs: \n" iter)
               (if (< (length eqs) 20)
                   (print-eqn eqs)
                   (printf "~a\n" (length eqs)))
               (printf "deferred: \n") (print-eqn deferred)
               (printf "cpairs: \n") (if (< (length cpairs) 20)
                                         (print-eqn cpairs)
                                         (printf "~a\n" (length cpairs)))
               (let ([e (ormap (curry normalize-oriented ord eqs) deferred)])
                 ;; TODO: Describe condition
                 (-basic-completion ord eqs (remove e deferred) '(e) max-iter (+ 1 iter)))))])))

(define (basic-completion ord eqs [max-iter 1000] [iter 0])
  (-basic-completion ord eqs '() (remove-duplicates (all-critical-pairs eqs)) max-iter iter))
#+END_SRC

#+NAME: basic-completion-tests
#+BEGIN_SRC scheme :eval yes :exports none :results silent
(let* ([ord (curry lpo-ge (curry op-gt '(i * e)))]
       [eqns (rewrite-rules (x y z)
               ((* e x) -> x)
               ((* (* x y) z) -> (* x (* y z)))
               ((* (i x) x) -> e))]
       [res (basic-completion ord eqns)])
  ;; (print-rule
  ;;  (sort (for/list ([x res]) (vars-to-symbols x (lambda (i) (var i))))
  ;;        (lambda (x y) (ord (car x) (car y)))))
  ;; We should have distributivity of inverses (i.e. `i'):
  ;; (printf "normalize test (distribute inverse): ~a\n"
  ;;         (normalize res `(i (* (* (* y z) u) y))))
  ;; (printf "normalize test (distribute and negate inverse): ~a\n"
  ;;         (normalize res `(i (* (i (* (* (* y z) u) y)) q))))
  (check-equal? (normalize res
                           `(* (i (* x (i x)))
                             (* (i (* (i (* (* y z) u)) y)) (i u))))
               'z))
#+END_SRC

* miniKanren Integrations

Certain uses of miniKanren reflect term-rewriting in such a way as to benefit
from the rewrite rule completion.

In the miniKanren DSL, constructs like src_scheme{conde} can implicitly specify a set of
rewrite rules \(\mathcal{R}\).  The general pattern of these rules is given by the
following:
#+ATTR_LATEX: :float t :placement h!
#+CAPTION:
#+NAME: conde-pattern-form
#+BEGIN_SRC scheme :eval never :results none :exports src
(fresh (l r)
  (conde
   ;; l_1 -> r_1
   ((== l L1)
    (== r R1))
   ;; l_2 -> r_2
   ((== l L2)
    (== r R2))
   ;;...
   ))
#+END_SRC

When the src_scheme{conde} forms are intercepted by a macro, one can parse the
branches and extract implicit rewrite rules.  This step could be performed in an
operator specifically for defining rewrite rules, or as a generalized miniKanren
"compilation" step that reasons about arbitrary forms in the unevaluated
miniKanren DSL (e.g. traverse src_scheme{fresh} and src_scheme{conde} forms for
potential \(l_i \to r_i\) rules).

** Graph Relations
The relations implemented here traverse graphs and apply other relations recursively.
#+NAME: mk-graph-relations
#+BEGIN_SRC scheme :eval yes :exports none :results silent :noweb-ref graph-relations
(define lapply-anyo
  (lambda (func l-in l-out)
    (letrec ((-lapply
              (lambda (-in -out i-any)
                (conde
                 ((fresh (i-car i-cdr o-car o-cdr o-any)
                    (== -in (cons i-car i-cdr))
                    (== -out (cons o-car o-cdr))
                    (conde
                     ((func i-car o-car)
                      (== o-any #t))
                     ((== i-car o-car)
                      (== o-any i-any)))
                    (-lapply i-cdr o-cdr o-any)))
                 ((== -in '())
                  (== i-any #t)
                  (== -out -in))))))
      (-lapply l-in l-out #f))))

(define graph-applyo
  (lambda (func g-in g-out)
    (conde
     ((fresh (i-rdc)
        (func g-in i-rdc)
        (conde
         ((== i-rdc g-out))
         ((graph-applyo func i-rdc g-out)))))
     ((fresh (i-rdc)
        (lapply-anyo
         (lambda (a b) (graph-applyo func a b))
         g-in i-rdc)
        (conde
         ((== i-rdc g-out))
         ((graph-applyo func i-rdc g-out))))))))

#+END_SRC

#+NAME: mk-graph-relations-tests
#+BEGIN_SRC scheme :eval yes :exports none :results silent
<<scheme-setup>>
<<graph-relations>>

(define reduces
  (lambda (a b)
    (conde
     ((fresh (x)
        (== a `(+ ,x ,x))
        (== b `(* 2 ,x))))
     ((fresh (x)
        (== a `(exp (log ,x)))
        (== b x))))))

(define reduceo
  (lambda (a b)
    (conde
     ((fresh (r)
        (reduces a r)
        (reduceo r b)))
     ((reduces a b)))))

(check-equal? (run* (q) (reduces '(* 5 5) q))
              '())
(check-equal? (run* (q) (reduceo '(+ 5 5) q))
              '((* 2 5)))
(check-equal? (run* (q) (reduceo '(exp (log (+ 5 5))) q))
              '((+ 5 5) (* 2 5)))


(check-equal? (run* (q) (lapply-anyo reduceo '() q)) '())


(check-equal? (run* (q) (lapply-anyo reduceo '((+ 1 1)) q))
              '(((* 2 1))))

(check-equal? (run* (q) (lapply-anyo reduceo '((+ 1 1) (+ 2 2)) q))
              '(((+ 1 1) (* 2 2))
                ((* 2 1) (+ 2 2))
                ((* 2 1) (* 2 2))))

(check-equal? (run* (q) (lapply-anyo reduceo '((* 5 5) (* 2 2)) q))
              '())
(check-equal? (run* (q) (lapply-anyo reduceo '((+ 5 5) (* 2 2)) q))
              '(((* 2 5)
                 (* 2 2))))
(check-equal? (run* (q) (lapply-anyo reduceo '((* 5 5) (+ 2 2)) q))
              '(((* 5 5)
                 (* 2 2))))


(check-equal? (run* (q) (graph-applyo reduces '(* 5 5) q))
              '())

(check-equal? (run* (q) (graph-applyo reduces '(+ 5 5) q))
              '((* 2 5)))

(check-equal? (run* (q) (graph-applyo
                         reduces
                         '(+ (exp (log 5)) 5)
                         q))
              '((+ 5 5)
                (* 2 5)))

(check-equal? (list->set (run* (q) (graph-applyo
                                    reduces
                                    '(+ (+ 5 (exp (log 5))) (+ 5 5))
                                    q)))
              (list->set '((+ (+ 5 (exp (log 5))) (* 2 5))
                           (+ (+ 5 5) (+ 5 5)) (* 2 (+ 5 5))
                           (+ (+ 5 5) (* 2 5)) (+ (+ 5 5) (* 2 5))
                           (+ (* 2 5) (* 2 5)) (* 2 (* 2 5)) (+ (* 2 5) (* 2 5))
                           (* 2 (* 2 5)) (+ (* 2 5) (+ 5 5)) (* 2 (* 2 5))
                           (+ (+ 5 5) (* 2 5)) (+ (* 2 5) (+ 5 5)) (+ (* 2 5) (* 2 5))
                           (* 2 (* 2 5)) (+ (* 2 5) (* 2 5)) (+ (* 2 5) (* 2 5))
                           (* 2 (* 2 5)) (+ (* 2 5) (* 2 5)) (* 2 (* 2 5))
                           (* 2 (* 2 5)) (+ (* 2 5) (* 2 5)) (+ (* 2 5) (* 2 5))
                           (* 2 (* 2 5)) (* 2 (* 2 5)))))

(check-equal? (run* (q) (graph-applyo
                         reduces
                         '(+ (exp (log 5)) 5)
                         '(+ 5 5)))
              '(_.0))

(check-equal? (run 5 (q) (graph-applyo reduces q 5))
              '((exp (log 5))
                (exp (log (exp (log 5))))
                (exp (log (exp (log (exp (log 5))))))
                (exp (log (exp (log (exp (log (exp (log 5))))))))
                (exp (exp (log (log 5))))))

(check-equal? (run 5 (q)
                   (fresh (r)
                     (graph-applyo reduces q `(* 2 ,r))))
              '((+ _.0 _.0)
                (exp (log (* 2 _.0)))
                (exp (log (+ _.0 _.0)))
                (exp (log (exp (log (* 2 _.0)))))
                (+ (+ _.0 _.0) (+ _.0 _.0))))
#+END_SRC

** Rewrite Relations

#+NAME: rule-operator
#+BEGIN_SRC scheme :eval never :exports none :results none
(define-syntax rewrite-rules
  (syntax-rules (->)
    ((_ (q ...) (l -> r) ...)
      ;; TODO: Call a function above that produces the critical pairs.
      ;; The output should ultimately be a set of "completed"
      ;; `conde' rewrite rules?
      `((,l ,r) ...))))
#+END_SRC

#+NAME: rule-extractor
#+BEGIN_SRC scheme :eval never :exports none :results none
(define-syntax extract-rewrite-rules
  (syntax-rules ()
    ((_ (conde
         ((== l x) ...))
        ;; TODO: Collect `(== l ...)` and `(== r ...)` pairs in
        ;; branches to form rewrite rules.  Maybe even replace/unique-ify
        ;; the involved logic variables.
     (`((,x ,y) ...)))))
#+END_SRC

* Discussion

:TODO:
- Summarize results
- Describe future work
- etc.
:END:

#+BIBLIOGRAPHY: ../tex/mk-term-rewriting.bib
#+BIBLIOGRAPHYSTYLE: plainnat

# Local Variables:
# geiser-scheme-implementation: racket
# eval: (cl-loop for x in '(rewrite-rules fresh match*) do (put x 'scheme-indent-function 1))
# End:
