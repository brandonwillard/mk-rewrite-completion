#+TITLE: Knuth-Bendix Completion in miniKanren
#+AUTHOR: Brandon T. Willard
#+DATE: 2018-03-28
#+EMAIL: brandonwillard@gmail.com

#+STARTUP: hideblocks indent hidestars
#+OPTIONS: author:t date:t ^:nil toc:nil title:t tex:t d:(not "logbook" "todo" "notes")
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport

#+PROPERTY: header-args :eval never :exports both :results output drawer replace
#+PROPERTY: header-args+ :session mk-rewrites

#+SETUPFILE: latex-setup.org
#+INCLUDE: org-setup.org

#+BEGIN_abstract
An investigation into the use of the Knuth-Bendix completion algorithm in
miniKanren.
#+END_abstract

* Introduction

The Knuth-Bendix algorithm [[citep:KnuthSimplewordproblems1983]] attempts
to complete a set of rewrite rules, \(\mathcal{R}\), for a set of terms
\(\mathcal{T}\left(\mathcal{F}, \mathcal{V}\right)\) derived from a set of
function symbols \(\mathcal{F}\) and variables \(\mathcal{V}\).  These are
combined to form a term rewriting system \(\left(\mathcal{R}, \mathcal{R}\right)\).

:EXAMPLE:
An example:
\begin{align}
  1 \cdot x &= x
  \\
  x^{-1} \cdot x &= 1
  \\
  (x \cdot y) \cdot z &= x \cdot (y \cdot z)
\end{align}
is completed as
\begin{align}
  1 \cdot x &\to x
  \\
  x^{-1} \cdot x &\to 1
  \\
  (x \cdot y) \cdot z &\to x \cdot (y \cdot z)
  \\
  x^{-1} \cdot (x \cdot y) &\to y
  \\
  1^{-1} &\to 1
  \\
  x \cdot 1 &\to x
  \\
  (x^{-1})^{-1} &\to x
  \\
  x \cdot x^{-1} &\to 1
  \\
  x \cdot (x^{-1} \cdot y) &\to y
  \\
  (x \cdot y)^{-1} &\to y^{-1} x^{-1}
\end{align}
:END:

* Rewrite Rules in miniKanren
Certain uses of miniKanren reflect term-rewriting in such a way as to benefit
from the rewrite rule completion provided by the Knuth-Bendix algorithm.

In the miniKanren DSL, constructs like src_scheme{conde} can implicitly specify a set of
rewrite rules \(\mathcal{R}\).  The general pattern of these rules is given by the
following:
#+BEGIN_SRC scheme :eval never :results none :exports src
(fresh (l r)
  (conde
   ;; l_1 -> r_1
   ((== l L1)
    (== r R1))
   ;; l_2 -> r_2
   ((== l L2)
    (== r R2))
   ;;...
   ))
#+END_SRC

When the src_scheme{conde} forms are intercepted by a macro, one can parse the
branches and extract implicit rewrite rules.  This step could be performed in an
operator specifically for defining rewrite rules, or as a generalized miniKanren
"compilation" step that reasons about arbitrary forms in the unevaluated
miniKanren DSL (e.g. traverse src_scheme{fresh} and src_scheme{conde} forms for
potential \(l_i \to r_i\) rules).

#+NAME: rule-operator
#+BEGIN_SRC scheme :eval never :exports none :results none
(define-syntax rewrite-rules
  (syntax-rules (->)
    ((_ (q ...) (l -> r) ...)
      ;; TODO: Call a function above that produces the critical pairs.
      ;; The output should ultimately be a set of "completed"
      ;; `conde' rewrite rules?
      `((,l ,r) ...))))
#+END_SRC

#+NAME: rule-extractor
#+BEGIN_SRC scheme :eval never :exports none :results none
(define-syntax extract-rewrite-rules
  (syntax-rules ()
    ((_ (conde
         ((== l x) ...))
        ;; TODO: Collect `(== l ...)` and `(== r ...)` pairs in
        ;; branches to form rewrite rules.  Maybe even replace/unique-ify
        ;; the involved logic variables.
     (`((,x ,y) ...)))))
#+END_SRC

:NOTES:
We might be able to construct relations for critical pairs.
#+BEGIN_SRC scheme :eval never :exports none :results none
(define reduces
  (lambda (a b)
    (conde
     ((fresh (x)
        (== a `(+ ,x ,x))
        (== b `(* 2 ,x))))
     ((fresh (x)
        (== a `(exp (log ,x)))
        (== b x))))))

(define reduceo
  (lambda (a b)
    (conde
     ((fresh (r)
        (reduces a r)
        (reduceo r b)))
     ((reduces a b)))))

(check-equal? (run* (q) (reduces '(* 5 5) q))
              '())
(check-equal? (run* (q) (reduceo '(+ 5 5) q))
              '((* 2 5)))
(check-equal? (run* (q) (reduceo '(exp (log (+ 5 5))) q))
              '((+ 5 5) (* 2 5)))


(define lapply-anyo
  (lambda (func l-in l-out)
    (letrec ((-lapply
              (lambda (-in -out i-any)
                (conde
                 ((fresh (i-car i-cdr o-car o-cdr o-any)
                    (== -in (cons i-car i-cdr))
                    (== -out (cons o-car o-cdr))
                    (conde
                     ((func i-car o-car)
                      (== o-any #t))
                     ((== i-car o-car)
                      (== o-any i-any)))
                    (-lapply i-cdr o-cdr o-any)))
                 ((== -in '())
                  (== i-any #t)
                  (== -out -in))))))
      (-lapply l-in l-out #f))))


(check-equal? (run* (q) (lapply-anyo reduceo '() q)) '())

(define graph-applyo
  (lambda (func g-in g-out)
    (conde
     ((fresh (i-rdc)
        (func g-in i-rdc)
        (conde
         ((== i-rdc g-out))
         ((graph-applyo func i-rdc g-out)))))
     ((fresh (i-rdc)
        (lapply-anyo
         (lambda (a b) (graph-applyo func a b))
         g-in i-rdc)
        (conde
         ((== i-rdc g-out))
         ((graph-applyo func i-rdc g-out))))))))


#+END_SRC
:END:

* Critical Pairs
The algorithm starts with the critical pairs,
\({\langle s, t \rangle} \in \operatorname{CP}(\mathcal{R})\).

Following [[citet:BaaderTermrewritingall1999]] Definition 6.2.1,
#+BEGIN_definition
For \(l_i \to r_i\), \(i \in \left\{1, 2\right\}\) with
\(\bigcap_{i \in \left\{1, 2\right\}} \mathcal{Var}\left(l_i, r_i\right) = \emptyset\),
let \(p \in \mathcal{Pos}\left(l_1\right)\) and \(\theta\) a most general
unifier of \(l_1 \mid_{p} =^{?} l_2\) s.t. \(l_1 \mid_{p}\) is not a variable, then
\(l_i \to r_i\) determine a *critical pair*
\({\langle \theta r_1, \left(\theta l_1\right)\left[\theta r_2\right]_p \rangle}\).
#+END_definition

#+NAME: compute-critical-pairs
#+BEGIN_SRC scheme :eval yes :exports none :results none
(require rackunit)
(require minikanren)

;; Include un-`provided` core functions.
(require/expose minikanren/minikanren (unify var var? reify walk*))

;; Compute critical pairs for sub-terms of a compound term graph.
(define critical-pairs-cons
  (lambda (l r l2 r2)
    (cond
     ((cons? l)
      (let* ([l-car (car l)]
             [l-cdr (cdr l)]
             [θ (if (not (var? l-car))
                    (unify l-car l2 '())
                    #f)]
             [cps (if (eq? θ #f)
                      '()
                      (list (cons (walk* r θ)
                                  (walk* (cons r2 l-cdr) θ))))]
             [cps (append (for/list ([h (critical-pairs-cons l-car r l2 r2)])
                            (cons (car h) (cons (cdr h) l-cdr))) cps)]
             [cps (append (for/list ([t (critical-pairs-cons l-cdr r l2 r2)])
                            (cons (car t) (cons l-car (cdr t)))) cps)])
        cps))
     (#t '()))))

;; Compute critical pairs for an arbitrary term graph.
(define critical-pairs
  (lambda (l r l2 r2)
    (if (var? l)
        '()
        (let ([θ (unify l l2 '())]
              [cps '()])
          (unless (eq? θ #f)
            (set! cps (cons `(,(reify r θ) . ,(reify r2 θ)) cps)))
          (when (cons? l)
            (set! cps (append (critical-pairs-cons l r l2 r2) cps)))
          cps))))
#+END_SRC

A simple example from [[citet:BaaderTermrewritingall1999]] Example 6.2.2:
#+BEGIN_SRC scheme :eval yes :exports results :results value code
(let ([x (var 0)]
      [y (var 1)]
      [z (var 2)]
      [x1 (var 3)])
  (critical-pairs `(f (f ,x ,y) ,z) ; ->
                  `(f ,x (f ,y ,z))
                  `(f (i ,x1) ,x1) ; ->
                  'e))
#+END_SRC

#+RESULTS:
#+begin_src scheme
(((f (i #(3)) (f #(3) #(2))) f e #(2)))
#+end_src

Now, all rules against each other:
#+BEGIN_SRC scheme :eval yes :exports results :results value code
(let* ([x (var 0)]
       [y (var 1)]
       [z (var 2)]
       [x1 (var 3)]
       ;; Create some test rules.
       ;; NOTE: Neither rule shares logic vars.
       [rules `(((f (f ,x ,y) ,z) . ; ->
                 (f ,x (f ,y ,z)))
                ((f (i ,x1) ,x1) . ; ->
                 'e))]
       ;; The critical pairs
       [c-pairs '()])
  ;; Loop through combinations of the rules.
  (for/list ([r (in-combinations rules 2)])
    (let* ([rule1 (car r)]
           [rule2 (cadr r)]
           [l (car rule1)]
           [r (cdr rule1)]
           [l2 (car rule2)]
           [r2 (cdr rule2)])
      (set! c-pairs (append (critical-pairs l r l2 r2) c-pairs))))
  c-pairs)
#+END_SRC

#+RESULTS:
#+begin_src scheme
(((f (i #(3)) (f #(3) #(2))) f (quote e) #(2)))
#+end_src

* Knuth-Bendix

:NOTES:
Some links:
 - [[https://github.com/moratori/kbcompl/blob/master/src/knuth-bendix.lisp][example Lisp implementation]]
 - [[https://github.com/nick8325/completion/blob/master/completion.pl][example Prolog implementation]]
:END:

#+BIBLIOGRAPHY: ../tex/mk-term-rewriting.bib
#+BIBLIOGRAPHYSTYLE: plainnat

# Local Variables:
# pyvenv-workon: "knuth-bendix-experiment"
# geiser-scheme-implementation: racket
# eval: (put 'fresh 'scheme-indent-function 1)
# End:
